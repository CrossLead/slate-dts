// Generated by dts-bundle v0.7.3

declare module 'slate' {
    /**
        * Models.
        */
    import Block from 'slate/models/block';
    import Character from 'slate/models/character';
    import Data from 'slate/models/data';
    import Document from 'slate/models/document';
    import History from 'slate/models/history';
    import Inline from 'slate/models/inline';
    import Mark from 'slate/models/mark';
    import Node from 'slate/models/node';
    import Schema from 'slate/models/schema';
    import Selection from 'slate/models/selection';
    import Stack from 'slate/models/stack';
    import State from 'slate/models/state';
    import Text from 'slate/models/text';
    import Range from 'slate/models/range';
    /**
        * Operations.
        */
    import Operations from 'slate/operations';
    /**
        * Changes.
        */
    import Changes from 'slate/changes';
    /**
        * Utils.
        */
    import { resetKeyGenerator, setKeyGenerator } from 'slate/utils/generate-key';
    /**
        * Export.
        *
        * @type {Object}
        */
    export { Block, Character, Data, Document, History, Inline, Mark, Node, Operations, Range, Schema, Selection, Stack, State, Text, Changes, resetKeyGenerator, setKeyGenerator };
    const _default: {
            Block: any;
            Character: any;
            Data: any;
            Document: any;
            History: any;
            Inline: any;
            Mark: any;
            Node: any;
            Operations: any;
            Range: any;
            Schema: any;
            Selection: any;
            Stack: any;
            State: any;
            Text: any;
            Changes: any;
            resetKeyGenerator: any;
            setKeyGenerator: any;
    };
    export default _default;
}

declare module 'slate/models/block' {
    /**
        * Prevent circular dependencies.
        */
    // import './document';
    const Block_base: any;
    /**
        * Block.
        *
        * @type {Block}
        */
    class Block extends Block_base {
            /**
                * Create a new `Block` from `value`.
                *
                * @param {Object|String|Block} value
                * @return {Block}
                */
            static create(value?: {}): any;
            /**
                * Create a list of `Blocks` from `value`.
                *
                * @param {Array<Block|Object>|List<Block|Object>} value
                * @return {List<Block>}
                */
            static createList(value?: any[]): any;
            /**
                * Create a `Block` from a JSON `object`.
                *
                * @param {Object|Block} object
                * @return {Block}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Block.fromJSON;
            /**
                * Check if a `value` is a `Block`.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isBlock(value: any): boolean;
            /**
                * Check if a `value` is a block list.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isBlockList(value: any): any;
            /**
                * Get the node's kind.
                *
                * @return {String}
                */
            readonly kind: string;
            /**
                * Check if the block is empty.
                *
                * @return {Boolean}
                */
            readonly isEmpty: boolean;
            /**
                * Get the concatenated text of all the block's children.
                *
                * @return {String}
                */
            readonly text: any;
            /**
                * Return a JSON representation of the block.
                *
                * @param {Object} options
                * @return {Object}
                */
            toJSON(options?: {}): {
                    data: any;
                    key: any;
                    kind: string;
                    isVoid: any;
                    type: any;
                    nodes: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(options: any): {
                    data: any;
                    key: any;
                    kind: string;
                    isVoid: any;
                    type: any;
                    nodes: any;
            };
    }
    export default Block;
}

declare module 'slate/models/character' {
    const Character_base: any;
    /**
        * Character.
        *
        * @type {Character}
        */
    class Character extends Character_base {
            /**
                * Create a `Character` with `attrs`.
                *
                * @param {Object|String|Character} attrs
                * @return {Character}
                */
            static create(attrs?: {}): any;
            /**
                * Create a list of `Characters` from `elements`.
                *
                * @param {String|Array<Object|Character|String>|List<Object|Character|String>} elements
                * @return {List<Character>}
                */
            static createList(elements?: any[]): any;
            /**
                * Create a `Character` from a JSON `object`.
                *
                * @param {Object} object
                * @return {Character}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Character.fromJSON;
            /**
                * Check if a `value` is a `Character`.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isCharacter(value: any): boolean;
            /**
                * Check if a `value` is a character list.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isCharacterList(value: any): any;
            /**
                * Deprecated.
                */
            static createListFromText(string: any): any;
            /**
                * Get the kind.
                *
                * @return {String}
                */
            readonly kind: string;
            /**
                * Return a JSON representation of the character.
                *
                * @return {Object}
                */
            toJSON(): {
                    kind: string;
                    marks: any;
                    text: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(): {
                    kind: string;
                    marks: any;
                    text: any;
            };
    }
    export default Character;
}

declare module 'slate/models/data' {
    /**
        * Data.
        *
        * This isn't an immutable record, it's just a thin wrapper around `Map` so that
        * we can allow for more convenient creation.
        *
        * @type {Object}
        */
    class Data {
            /**
                * Create a new `Data` with `attrs`.
                *
                * @param {Object|Data|Map} attrs
                * @return {Data} data
                */
            static create(attrs?: {}): any;
            /**
                * Create a `Data` from a JSON `object`.
                *
                * @param {Object} object
                * @return {Data}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Data.fromJSON;
    }
    export default Data;
}

declare module 'slate/models/document' {
    /**
        * Prevent circular dependencies.
        */
    // import './block';
    // import './inline';
    const Document_base: any;
    /**
        * Document.
        *
        * @type {Document}
        */
    class Document extends Document_base {
            /**
                * Create a new `Document` with `attrs`.
                *
                * @param {Object|Array|List|Text} attrs
                * @return {Document}
                */
            static create(attrs?: {}): any;
            /**
                * Create a `Document` from a JSON `object`.
                *
                * @param {Object|Document} object
                * @return {Document}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Document.fromJSON;
            /**
                * Check if a `value` is a `Document`.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isDocument(value: any): boolean;
            /**
                * Get the node's kind.
                *
                * @return {String}
                */
            readonly kind: string;
            /**
                * Check if the document is empty.
                *
                * @return {Boolean}
                */
            readonly isEmpty: boolean;
            /**
                * Get the concatenated text of all the document's children.
                *
                * @return {String}
                */
            readonly text: any;
            /**
                * Return a JSON representation of the document.
                *
                * @param {Object} options
                * @return {Object}
                */
            toJSON(options?: {}): {
                    data: any;
                    key: any;
                    kind: string;
                    nodes: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(options: any): {
                    data: any;
                    key: any;
                    kind: string;
                    nodes: any;
            };
    }
    export default Document;
}

declare module 'slate/models/history' {
    const History_base: any;
    /**
        * History.
        *
        * @type {History}
        */
    class History extends History_base {
            /**
                * Create a new `History` with `attrs`.
                *
                * @param {Object|History} attrs
                * @return {History}
                */
            static create(attrs?: {}): any;
            /**
                * Create a `History` from a JSON `object`.
                *
                * @param {Object} object
                * @return {History}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof History.fromJSON;
            /**
                * Check if a `value` is a `History`.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isHistory(value: any): boolean;
            /**
                * Get the kind.
                *
                * @return {String}
                */
            readonly kind: string;
            /**
                * Save an `operation` into the history.
                *
                * @param {Object} operation
                * @param {Object} options
                * @return {History}
                */
            save(operation: any, options?: {}): this;
            /**
                * Return a JSON representation of the history.
                *
                * @return {Object}
                */
            toJSON(): {
                    kind: string;
                    redos: any;
                    undos: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(): {
                    kind: string;
                    redos: any;
                    undos: any;
            };
    }
    export default History;
}

declare module 'slate/models/inline' {
    /**
        * Prevent circular dependencies.
        */
    // import './document';
    const Inline_base: any;
    /**
        * Inline.
        *
        * @type {Inline}
        */
    class Inline extends Inline_base {
            /**
                * Create a new `Inline` with `attrs`.
                *
                * @param {Object|String|Inline} attrs
                * @return {Inline}
                */
            static create(attrs?: {}): any;
            /**
                * Create a list of `Inlines` from an array.
                *
                * @param {Array<Inline|Object>|List<Inline|Object>} elements
                * @return {List<Inline>}
                */
            static createList(elements?: any[]): any;
            /**
                * Create a `Inline` from a JSON `object`.
                *
                * @param {Object|Inline} object
                * @return {Inline}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Inline.fromJSON;
            /**
                * Check if a `value` is a `Inline`.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isInline(value: any): boolean;
            /**
                * Check if a `value` is a list of inlines.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isInlineList(value: any): any;
            /**
                * Get the node's kind.
                *
                * @return {String}
                */
            readonly kind: string;
            /**
                * Check if the inline is empty.
                *
                * @return {Boolean}
                */
            readonly isEmpty: boolean;
            /**
                * Get the concatenated text of all the inline's children.
                *
                * @return {String}
                */
            readonly text: any;
            /**
                * Return a JSON representation of the inline.
                *
                * @param {Object} options
                * @return {Object}
                */
            toJSON(options?: {}): {
                    data: any;
                    key: any;
                    kind: string;
                    isVoid: any;
                    type: any;
                    nodes: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(options: any): {
                    data: any;
                    key: any;
                    kind: string;
                    isVoid: any;
                    type: any;
                    nodes: any;
            };
    }
    export default Inline;
}

declare module 'slate/models/mark' {
    const Mark_base: any;
    /**
        * Mark.
        *
        * @type {Mark}
        */
    class Mark extends Mark_base {
            /**
                * Create a new `Mark` with `attrs`.
                *
                * @param {Object|Mark} attrs
                * @return {Mark}
                */
            static create(attrs?: {}): any;
            /**
                * Create a set of marks.
                *
                * @param {Array<Object|Mark>} elements
                * @return {Set<Mark>}
                */
            static createSet(elements: any): any;
            /**
                * Create a dictionary of settable mark properties from `attrs`.
                *
                * @param {Object|String|Mark} attrs
                * @return {Object}
                */
            static createProperties(attrs?: {}): {} | {
                    data: any;
                    type: any;
            } | {
                    type: string;
            };
            /**
                * Create a `Mark` from a JSON `object`.
                *
                * @param {Object} object
                * @return {Mark}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Mark.fromJSON;
            /**
                * Check if a `value` is a `Mark`.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isMark(value: any): boolean;
            /**
                * Check if a `value` is a set of marks.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isMarkSet(value: any): any;
            /**
                * Get the kind.
                */
            readonly kind: string;
            /**
                * Get the component for the node from a `schema`.
                *
                * @param {Schema} schema
                * @return {Component|Void}
                */
            getComponent(schema: any): any;
            /**
                * Return a JSON representation of the mark.
                *
                * @return {Object}
                */
            toJSON(): {
                    data: any;
                    kind: string;
                    type: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(): {
                    data: any;
                    kind: string;
                    type: any;
            };
    }
    export default Mark;
}

declare module 'slate/models/node' {
    /**
        * Node.
        *
        * And interface that `Document`, `Block` and `Inline` all implement, to make
        * working with the recursive node tree easier.
        *
        * @type {Node}
        */
    class Node {
            /**
                * Create a new `Node` with `attrs`.
                *
                * @param {Object|Node} attrs
                * @return {Node}
                */
            static create(attrs?: {}): any;
            /**
                * Create a list of `Nodes` from an array.
                *
                * @param {Array<Object|Node>} elements
                * @return {List<Node>}
                */
            static createList(elements?: any[]): any;
            /**
                * Create a dictionary of settable node properties from `attrs`.
                *
                * @param {Object|String|Node} attrs
                * @return {Object}
                */
            static createProperties(attrs?: {}): {} | {
                    data: any;
                    isVoid: any;
                    type: any;
            } | {
                    type: string;
            };
            /**
                * Create a `Node` from a JSON `object`.
                *
                * @param {Object} object
                * @return {Node}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Node.fromJSON;
            /**
                * Check if a `value` is a `Node`.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isNode(value: any): any;
            /**
                * Check if a `value` is a list of nodes.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isNodeList(value: any): any;
            /**
                * True if the node has both descendants in that order, false otherwise. The
                * order is depth-first, post-order.
                *
                * @param {String} first
                * @param {String} second
                * @return {Boolean}
                */
            areDescendantsSorted(first: any, second: any): any;
            /**
                * Assert that a node has a child by `key` and return it.
                *
                * @param {String} key
                * @return {Node}
                */
            assertChild(key: any): any;
            /**
                * Assert that a node has a descendant by `key` and return it.
                *
                * @param {String} key
                * @return {Node}
                */
            assertDescendant(key: any): any;
            /**
                * Assert that a node's tree has a node by `key` and return it.
                *
                * @param {String} key
                * @return {Node}
                */
            assertNode(key: any): any;
            /**
                * Assert that a node exists at `path` and return it.
                *
                * @param {Array} path
                * @return {Node}
                */
            assertPath(path: any): this;
            /**
                * Recursively filter all descendant nodes with `iterator`.
                *
                * @param {Function} iterator
                * @return {List<Node>}
                */
            filterDescendants(iterator: any): any;
            /**
                * Recursively find all descendant nodes by `iterator`.
                *
                * @param {Function} iterator
                * @return {Node|Null}
                */
            findDescendant(iterator: any): any;
            /**
                * Recursively iterate over all descendant nodes with `iterator`. If the
                * iterator returns false it will break the loop.
                *
                * @param {Function} iterator
                */
            forEachDescendant(iterator: any): any;
            /**
                * Get the path of ancestors of a descendant node by `key`.
                *
                * @param {String|Node} key
                * @return {List<Node>|Null}
                */
            getAncestors(key: any): any;
            /**
                * Get the leaf block descendants of the node.
                *
                * @return {List<Node>}
                */
            getBlocks(): any;
            /**
                * Get the leaf block descendants of the node.
                *
                * @return {List<Node>}
                */
            getBlocksAsArray(): any;
            /**
                * Get the leaf block descendants in a `range`.
                *
                * @param {Selection} range
                * @return {List<Node>}
                */
            getBlocksAtRange(range: any): any;
            /**
                * Get the leaf block descendants in a `range` as an array
                *
                * @param {Selection} range
                * @return {Array}
                */
            getBlocksAtRangeAsArray(range: any): any;
            /**
                * Get all of the leaf blocks that match a `type`.
                *
                * @param {String} type
                * @return {List<Node>}
                */
            getBlocksByType(type: any): any;
            /**
                * Get all of the leaf blocks that match a `type` as an array
                *
                * @param {String} type
                * @return {Array}
                */
            getBlocksByTypeAsArray(type: any): any;
            /**
                * Get all of the characters for every text node.
                *
                * @return {List<Character>}
                */
            getCharacters(): any;
            /**
                * Get all of the characters for every text node as an array
                *
                * @return {Array}
                */
            getCharactersAsArray(): any;
            /**
                * Get a list of the characters in a `range`.
                *
                * @param {Selection} range
                * @return {List<Character>}
                */
            getCharactersAtRange(range: any): any;
            /**
                * Get a list of the characters in a `range` as an array.
                *
                * @param {Selection} range
                * @return {Array}
                */
            getCharactersAtRangeAsArray(range: any): any;
            /**
                * Get a child node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getChild(key: any): any;
            /**
                * Get closest parent of node by `key` that matches `iterator`.
                *
                * @param {String} key
                * @param {Function} iterator
                * @return {Node|Null}
                */
            getClosest(key: any, iterator: any): any;
            /**
                * Get the closest block parent of a `node`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getClosestBlock(key: any): any;
            /**
                * Get the closest inline parent of a `node`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getClosestInline(key: any): any;
            /**
                * Get the closest void parent of a `node`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getClosestVoid(key: any): any;
            /**
                * Get the common ancestor of nodes `one` and `two` by keys.
                *
                * @param {String} one
                * @param {String} two
                * @return {Node}
                */
            getCommonAncestor(one: any, two: any): any;
            /**
                * Get the component for the node from a `schema`.
                *
                * @param {Schema} schema
                * @return {Component|Void}
                */
            getComponent(schema: any): any;
            /**
                * Get the decorations for the node from a `schema`.
                *
                * @param {Schema} schema
                * @return {Array}
                */
            getDecorators(schema: any): any;
            /**
                * Get the depth of a child node by `key`, with optional `startAt`.
                *
                * @param {String} key
                * @param {Number} startAt (optional)
                * @return {Number} depth
                */
            getDepth(key: any, startAt?: number): any;
            /**
                * Get a descendant node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getDescendant(key: any): any;
            /**
                * Get a descendant by `path`.
                *
                * @param {Array} path
                * @return {Node|Null}
                */
            getDescendantAtPath(path: any): this;
            /**
                * Get the decorators for a descendant by `key` given a `schema`.
                *
                * @param {String} key
                * @param {Schema} schema
                * @return {Array}
                */
            getDescendantDecorators(key: any, schema: any): any[];
            /**
                * Get the first child text node.
                *
                * @return {Node|Null}
                */
            getFirstText(): any;
            /**
                * Get a fragment of the node at a `range`.
                *
                * @param {Selection} range
                * @return {Document}
                */
            getFragmentAtRange(range: any): any;
            /**
                * Get the furthest parent of a node by `key` that matches an `iterator`.
                *
                * @param {String} key
                * @param {Function} iterator
                * @return {Node|Null}
                */
            getFurthest(key: any, iterator: any): any;
            /**
                * Get the furthest block parent of a node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getFurthestBlock(key: any): any;
            /**
                * Get the furthest inline parent of a node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getFurthestInline(key: any): any;
            /**
                * Get the furthest ancestor of a node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getFurthestAncestor(key: any): any;
            /**
                * Get the furthest ancestor of a node by `key` that has only one child.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getFurthestOnlyChildAncestor(key: any): any;
            /**
                * Get the closest inline nodes for each text node in the node.
                *
                * @return {List<Node>}
                */
            getInlines(): any;
            /**
                * Get the closest inline nodes for each text node in the node, as an array.
                *
                * @return {List<Node>}
                */
            getInlinesAsArray(): any[];
            /**
                * Get the closest inline nodes for each text node in a `range`.
                *
                * @param {Selection} range
                * @return {List<Node>}
                */
            getInlinesAtRange(range: any): any;
            /**
                * Get the closest inline nodes for each text node in a `range` as an array.
                *
                * @param {Selection} range
                * @return {Array}
                */
            getInlinesAtRangeAsArray(range: any): any[];
            /**
                * Get all of the leaf inline nodes that match a `type`.
                *
                * @param {String} type
                * @return {List<Node>}
                */
            getInlinesByType(type: any): any;
            /**
                * Get all of the leaf inline nodes that match a `type` as an array.
                *
                * @param {String} type
                * @return {Array}
                */
            getInlinesByTypeAsArray(type: any): any;
            /**
                * Return a set of all keys in the node.
                *
                * @return {Set<String>}
                */
            getKeys(): any;
            /**
                * Get the last child text node.
                *
                * @return {Node|Null}
                */
            getLastText(): any;
            /**
                * Get all of the marks for all of the characters of every text node.
                *
                * @return {Set<Mark>}
                */
            getMarks(): any;
            /**
                * Get all of the marks for all of the characters of every text node.
                *
                * @return {OrderedSet<Mark>}
                */
            getOrderedMarks(): any;
            /**
                * Get all of the marks as an array.
                *
                * @return {Array}
                */
            getMarksAsArray(): any;
            /**
                * Get a set of the marks in a `range`.
                *
                * @param {Selection} range
                * @return {Set<Mark>}
                */
            getMarksAtRange(range: any): any;
            /**
                * Get a set of the marks in a `range`.
                *
                * @param {Selection} range
                * @return {OrderedSet<Mark>}
                */
            getOrderedMarksAtRange(range: any): any;
            /**
                * Get a set of the active marks in a `range`.
                *
                * @param {Selection} range
                * @return {Set<Mark>}
                */
            getActiveMarksAtRange(range: any): any;
            /**
                * Get a set of the marks in a `range`, by unioning.
                *
                * @param {Selection} range
                * @return {Array}
                */
            getMarksAtRangeAsArray(range: any): any;
            /**
                * Get a set of marks in a `range`, by intersecting.
                *
                * @param {Selection} range
                * @return {Array}
                */
            getActiveMarksAtRangeAsArray(range: any): any;
            /**
                * Get all of the marks that match a `type`.
                *
                * @param {String} type
                * @return {Set<Mark>}
                */
            getMarksByType(type: any): any;
            /**
                * Get all of the marks that match a `type`.
                *
                * @param {String} type
                * @return {OrderedSet<Mark>}
                */
            getOrderedMarksByType(type: any): any;
            /**
                * Get all of the marks that match a `type` as an array.
                *
                * @param {String} type
                * @return {Array}
                */
            getMarksByTypeAsArray(type: any): any;
            /**
                * Get the block node before a descendant text node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getNextBlock(key: any): any;
            /**
                * Get the node after a descendant by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getNextSibling(key: any): any;
            /**
                * Get the text node after a descendant text node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getNextText(key: any): any;
            /**
                * Get a node in the tree by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getNode(key: any): any;
            /**
                * Get a node in the tree by `path`.
                *
                * @param {Array} path
                * @return {Node|Null}
                */
            getNodeAtPath(path: any): this;
            /**
                * Get the offset for a descendant text node by `key`.
                *
                * @param {String} key
                * @return {Number}
                */
            getOffset(key: any): any;
            /**
                * Get the offset from a `range`.
                *
                * @param {Selection} range
                * @return {Number}
                */
            getOffsetAtRange(range: any): any;
            /**
                * Get the parent of a child node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getParent(key: any): any;
            /**
                * Get the path of a descendant node by `key`.
                *
                * @param {String|Node} key
                * @return {Array}
                */
            getPath(key: any): any[];
            /**
                * Get the block node before a descendant text node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getPreviousBlock(key: any): any;
            /**
                * Get the node before a descendant node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getPreviousSibling(key: any): any;
            /**
                * Get the text node before a descendant text node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getPreviousText(key: any): any;
            /**
                * Get the indexes of the selection for a `range`, given an extra flag for
                * whether the node `isSelected`, to determine whether not finding matches
                * means everything is selected or nothing is.
                *
                * @param {Selection} range
                * @param {Boolean} isSelected
                * @return {Object|Null}
                */
            getSelectionIndexes(range: any, isSelected?: boolean): {
                    start: any;
                    end: any;
            };
            /**
                * Get the concatenated text string of all child nodes.
                *
                * @return {String}
                */
            getText(): any;
            /**
                * Get the descendent text node at an `offset`.
                *
                * @param {String} offset
                * @return {Node|Null}
                */
            getTextAtOffset(offset: any): any;
            /**
                * Get the direction of the node's text.
                *
                * @return {String}
                */
            getTextDirection(): any;
            /**
                * Recursively get all of the child text nodes in order of appearance.
                *
                * @return {List<Node>}
                */
            getTexts(): any;
            /**
                * Recursively get all the leaf text nodes in order of appearance, as array.
                *
                * @return {List<Node>}
                */
            getTextsAsArray(): any[];
            /**
                * Get all of the text nodes in a `range`.
                *
                * @param {Selection} range
                * @return {List<Node>}
                */
            getTextsAtRange(range: any): any;
            /**
                * Get all of the text nodes in a `range` as an array.
                *
                * @param {Selection} range
                * @return {Array}
                */
            getTextsAtRangeAsArray(range: any): any[];
            /**
                * Check if a child node exists by `key`.
                *
                * @param {String} key
                * @return {Boolean}
                */
            hasChild(key: any): boolean;
            /**
                * Recursively check if a child node exists by `key`.
                *
                * @param {String} key
                * @return {Boolean}
                */
            hasDescendant(key: any): boolean;
            /**
                * Recursively check if a node exists by `key`.
                *
                * @param {String} key
                * @return {Boolean}
                */
            hasNode(key: any): boolean;
            /**
                * Check if a node has a void parent by `key`.
                *
                * @param {String} key
                * @return {Boolean}
                */
            hasVoidParent(key: any): boolean;
            /**
                * Insert a `node` at `index`.
                *
                * @param {Number} index
                * @param {Node} node
                * @return {Node}
                */
            insertNode(index: any, node: any): any;
            /**
                * Check whether the node is in a `range`.
                *
                * @param {Selection} range
                * @return {Boolean}
                */
            isInRange(range: any): boolean;
            /**
                * Check whether the node is a leaf block.
                *
                * @return {Boolean}
                */
            isLeafBlock(): any;
            /**
                * Check whether the node is a leaf inline.
                *
                * @return {Boolean}
                */
            isLeafInline(): any;
            /**
                * Merge a children node `first` with another children node `second`.
                * `first` and `second` will be concatenated in that order.
                * `first` and `second` must be two Nodes or two Text.
                *
                * @param {Node} first
                * @param {Node} second
                * @return {Node}
                */
            mergeNode(withIndex: any, index: any): this;
            /**
                * Map all child nodes, updating them in their parents. This method is
                * optimized to not return a new node if no changes are made.
                *
                * @param {Function} iterator
                * @return {Node}
                */
            mapChildren(iterator: any): any;
            /**
                * Map all descendant nodes, updating them in their parents. This method is
                * optimized to not return a new node if no changes are made.
                *
                * @param {Function} iterator
                * @return {Node}
                */
            mapDescendants(iterator: any): any;
            /**
                * Regenerate the node's key.
                *
                * @return {Node}
                */
            regenerateKey(): any;
            /**
                * Remove a `node` from the children node map.
                *
                * @param {String} key
                * @return {Node}
                */
            removeDescendant(key: any): this;
            /**
                * Remove a node at `index`.
                *
                * @param {Number} index
                * @return {Node}
                */
            removeNode(index: any): any;
            /**
                * Split a child node by `index` at `position`.
                *
                * @param {Number} index
                * @param {Number} position
                * @return {Node}
                */
            splitNode(index: any, position: any): this;
            /**
                * Set a new value for a child node by `key`.
                *
                * @param {Node} node
                * @return {Node}
                */
            updateNode(node: any): any;
            /**
                * Validate the node against a `schema`.
                *
                * @param {Schema} schema
                * @return {Object|Null}
                */
            validate(schema: any): any;
            /**
                * True if the node has both descendants in that order, false otherwise. The
                * order is depth-first, post-order.
                *
                * @param {String} first
                * @param {String} second
                * @return {Boolean}
                */
            areDescendantSorted(first: any, second: any): any;
            /**
                * Concat children `nodes` on to the end of the node.
                *
                * @param {List<Node>} nodes
                * @return {Node}
                */
            concatChildren(nodes: any): any;
            /**
                * Decorate all of the text nodes with a `decorator` function.
                *
                * @param {Function} decorator
                * @return {Node}
                */
            decorateTexts(decorator: any): any;
            /**
                * Recursively filter all descendant nodes with `iterator`, depth-first.
                * It is different from `filterDescendants` in regard of the order of results.
                *
                * @param {Function} iterator
                * @return {List<Node>}
                */
            filterDescendantsDeep(iterator: any): any;
            /**
                * Recursively find all descendant nodes by `iterator`. Depth first.
                *
                * @param {Function} iterator
                * @return {Node|Null}
                */
            findDescendantDeep(iterator: any): any;
            /**
                * Get children between two child keys.
                *
                * @param {String} start
                * @param {String} end
                * @return {Node}
                */
            getChildrenBetween(start: any, end: any): any;
            /**
                * Get children between two child keys, including the two children.
                *
                * @param {String} start
                * @param {String} end
                * @return {Node}
                */
            getChildrenBetweenIncluding(start: any, end: any): any;
            /**
                * Get the highest child ancestor of a node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getHighestChild(key: any): any;
            /**
                * Get the highest parent of a node by `key` which has an only child.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getHighestOnlyChildParent(key: any): any;
            /**
                * Check if the inline nodes are split at a `range`.
                *
                * @param {Selection} range
                * @return {Boolean}
                */
            isInlineSplitAtRange(range: any): any;
    }
    export default Node;
}

declare module 'slate/models/schema' {
    const Schema_base: any;
    /**
        * Schema.
        *
        * @type {Schema}
        */
    class Schema extends Schema_base {
            /**
                * Create a new `Schema` with `attrs`.
                *
                * @param {Object|Schema} attrs
                * @return {Schema}
                */
            static create(attrs?: {}): any;
            /**
                * Check if a `value` is a `Schema`.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isSchema(value: any): boolean;
            /**
                * Create a `Schema` from a JSON `object`.
                *
                * @param {Object} object
                * @return {Schema}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Schema.fromJSON;
            /**
                * Get the kind.
                *
                * @return {String}
                */
            readonly kind: string;
            /**
                * Return true if one rule can normalize the document
                *
                * @return {Boolean}
                */
            readonly hasValidators: any;
            /**
                * Return true if one rule can decorate text nodes
                *
                * @return {Boolean}
                */
            readonly hasDecorators: any;
            /**
                * Return the renderer for an `object`.
                *
                * This method is private, because it should always be called on one of the
                * often-changing immutable objects instead, since it will be memoized for
                * much better performance.
                *
                * @param {Mixed} object
                * @return {Component|Void}
                */
            __getComponent(object: any): any;
            /**
                * Return the decorators for an `object`.
                *
                * This method is private, because it should always be called on one of the
                * often-changing immutable objects instead, since it will be memoized for
                * much better performance.
                *
                * @param {Mixed} object
                * @return {Array}
                */
            __getDecorators(object: any): any;
            /**
                * Validate an `object` against the schema, returning the failing rule and
                * value if the object is invalid, or void if it's valid.
                *
                * This method is private, because it should always be called on one of the
                * often-changing immutable objects instead, since it will be memoized for
                * much better performance.
                *
                * @param {Mixed} object
                * @return {Object|Void}
                */
            __validate(object: any): {
                    rule: any;
                    value: any;
            };
    }
    export default Schema;
}

declare module 'slate/models/selection' {
    const Selection_base: any;
    /**
        * Selection.
        *
        * @type {Selection}
        */
    class Selection extends Selection_base {
            /**
                * Create a new `Selection` with `attrs`.
                *
                * @param {Object|Selection} attrs
                * @return {Selection}
                */
            static create(attrs?: {}): any;
            /**
                * Create a dictionary of settable selection properties from `attrs`.
                *
                * @param {Object|String|Selection} attrs
                * @return {Object}
                */
            static createProperties(attrs?: {}): {} | {
                    anchorKey: any;
                    anchorOffset: any;
                    focusKey: any;
                    focusOffset: any;
                    isBackward: any;
                    isFocused: any;
                    marks: any;
            };
            /**
                * Create a `Selection` from a JSON `object`.
                *
                * @param {Object} object
                * @return {Selection}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Selection.fromJSON;
            /**
                * Check if a `value` is a `Selection`.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isSelection(value: any): boolean;
            /**
                * Get the kind.
                *
                * @return {String}
                */
            readonly kind: string;
            /**
                * Check whether the selection is blurred.
                *
                * @return {Boolean}
                */
            readonly isBlurred: boolean;
            /**
                * Check whether the selection is collapsed.
                *
                * @return {Boolean}
                */
            readonly isCollapsed: boolean;
            /**
                * Check whether the selection is expanded.
                *
                * @return {Boolean}
                */
            readonly isExpanded: boolean;
            /**
                * Check whether the selection is forward.
                *
                * @return {Boolean}
                */
            readonly isForward: boolean;
            /**
                * Check whether the selection's keys are set.
                *
                * @return {Boolean}
                */
            readonly isSet: boolean;
            /**
                * Check whether the selection's keys are not set.
                *
                * @return {Boolean}
                */
            readonly isUnset: boolean;
            /**
                * Get the start key.
                *
                * @return {String}
                */
            readonly startKey: any;
            /**
                * Get the start offset.
                *
                * @return {String}
                */
            readonly startOffset: any;
            /**
                * Get the end key.
                *
                * @return {String}
                */
            readonly endKey: any;
            /**
                * Get the end offset.
                *
                * @return {String}
                */
            readonly endOffset: any;
            /**
                * Check whether anchor point of the selection is at the start of a `node`.
                *
                * @param {Node} node
                * @return {Boolean}
                */
            hasAnchorAtStartOf(node: any): boolean;
            /**
                * Check whether anchor point of the selection is at the end of a `node`.
                *
                * @param {Node} node
                * @return {Boolean}
                */
            hasAnchorAtEndOf(node: any): boolean;
            /**
                * Check whether the anchor edge of a selection is in a `node` and at an
                * offset between `start` and `end`.
                *
                * @param {Node} node
                * @param {Number} start
                * @param {Number} end
                * @return {Boolean}
                */
            hasAnchorBetween(node: any, start: any, end: any): any;
            /**
                * Check whether the anchor edge of a selection is in a `node`.
                *
                * @param {Node} node
                * @return {Boolean}
                */
            hasAnchorIn(node: any): any;
            /**
                * Check whether focus point of the selection is at the end of a `node`.
                *
                * @param {Node} node
                * @return {Boolean}
                */
            hasFocusAtEndOf(node: any): boolean;
            /**
                * Check whether focus point of the selection is at the start of a `node`.
                *
                * @param {Node} node
                * @return {Boolean}
                */
            hasFocusAtStartOf(node: any): boolean;
            /**
                * Check whether the focus edge of a selection is in a `node` and at an
                * offset between `start` and `end`.
                *
                * @param {Node} node
                * @param {Number} start
                * @param {Number} end
                * @return {Boolean}
                */
            hasFocusBetween(node: any, start: any, end: any): any;
            /**
                * Check whether the focus edge of a selection is in a `node`.
                *
                * @param {Node} node
                * @return {Boolean}
                */
            hasFocusIn(node: any): any;
            /**
                * Check whether the selection is at the start of a `node`.
                *
                * @param {Node} node
                * @return {Boolean}
                */
            isAtStartOf(node: any): boolean;
            /**
                * Check whether the selection is at the end of a `node`.
                *
                * @param {Node} node
                * @return {Boolean}
                */
            isAtEndOf(node: any): boolean;
            /**
                * Focus the selection.
                *
                * @return {Selection}
                */
            focus(): any;
            /**
                * Blur the selection.
                *
                * @return {Selection}
                */
            blur(): any;
            /**
                * Unset the selection.
                *
                * @return {Selection}
                */
            deselect(): any;
            /**
                * Flip the selection.
                *
                * @return {Selection}
                */
            flip(): any;
            /**
                * Move the anchor offset `n` characters.
                *
                * @param {Number} n (optional)
                * @return {Selection}
                */
            moveAnchor(n?: number): any;
            /**
                * Move the anchor offset `n` characters.
                *
                * @param {Number} n (optional)
                * @return {Selection}
                */
            moveFocus(n?: number): any;
            /**
                * Move the selection's anchor point to a `key` and `offset`.
                *
                * @param {String} key
                * @param {Number} offset
                * @return {Selection}
                */
            moveAnchorTo(key: any, offset: any): any;
            /**
                * Move the selection's focus point to a `key` and `offset`.
                *
                * @param {String} key
                * @param {Number} offset
                * @return {Selection}
                */
            moveFocusTo(key: any, offset: any): any;
            /**
                * Move the selection to `anchorOffset`.
                *
                * @param {Number} anchorOffset
                * @return {Selection}
                */
            moveAnchorOffsetTo(anchorOffset: any): any;
            /**
                * Move the selection to `focusOffset`.
                *
                * @param {Number} focusOffset
                * @return {Selection}
                */
            moveFocusOffsetTo(focusOffset: any): any;
            /**
                * Move the selection to `anchorOffset` and `focusOffset`.
                *
                * @param {Number} anchorOffset
                * @param {Number} focusOffset (optional)
                * @return {Selection}
                */
            moveOffsetsTo(anchorOffset: any, focusOffset?: any): any;
            /**
                * Move the focus point to the anchor point.
                *
                * @return {Selection}
                */
            moveToAnchor(): any;
            /**
                * Move the anchor point to the focus point.
                *
                * @return {Selection}
                */
            moveToFocus(): any;
            /**
                * Move the selection's anchor point to the start of a `node`.
                *
                * @param {Node} node
                * @return {Selection}
                */
            moveAnchorToStartOf(node: any): any;
            /**
                * Move the selection's anchor point to the end of a `node`.
                *
                * @param {Node} node
                * @return {Selection}
                */
            moveAnchorToEndOf(node: any): any;
            /**
                * Move the selection's focus point to the start of a `node`.
                *
                * @param {Node} node
                * @return {Selection}
                */
            moveFocusToStartOf(node: any): any;
            /**
                * Move the selection's focus point to the end of a `node`.
                *
                * @param {Node} node
                * @return {Selection}
                */
            moveFocusToEndOf(node: any): any;
            /**
                * Move to the entire range of `start` and `end` nodes.
                *
                * @param {Node} start
                * @param {Node} end (optional)
                * @return {Selection}
                */
            moveToRangeOf(start: any, end?: any): any;
            /**
                * Normalize the selection, relative to a `node`, ensuring that the anchor
                * and focus nodes of the selection always refer to leaf text nodes.
                *
                * @param {Node} node
                * @return {Selection}
                */
            normalize(node: any): any;
            /**
                * Return a JSON representation of the selection.
                *
                * @return {Object}
                */
            toJSON(): {
                    anchorKey: any;
                    anchorOffset: any;
                    focusKey: any;
                    focusOffset: any;
                    isBackward: any;
                    isFocused: any;
                    kind: string;
                    marks: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(): {
                    anchorKey: any;
                    anchorOffset: any;
                    focusKey: any;
                    focusOffset: any;
                    isBackward: any;
                    isFocused: any;
                    kind: string;
                    marks: any;
            };
            /**
                * Unset the selection.
                *
                * @return {Selection}
                */
            unset(): any;
            /**
                * Move the selection forward `n` characters.
                *
                * @param {Number} n (optional)
                * @return {Selection}
                */
            moveForward(n?: number): any;
            /**
                * Move the selection backward `n` characters.
                *
                * @param {Number} n (optional)
                * @return {Selection}
                */
            moveBackward(n?: number): any;
            /**
                * Move the anchor offset `n` characters.
                *
                * @param {Number} n (optional)
                * @return {Selection}
                */
            moveAnchorOffset(n?: number): any;
            /**
                * Move the focus offset `n` characters.
                *
                * @param {Number} n (optional)
                * @return {Selection}
                */
            moveFocusOffset(n?: number): any;
            /**
                * Move the start offset `n` characters.
                *
                * @param {Number} n (optional)
                * @return {Selection}
                */
            moveStartOffset(n?: number): any;
            /**
                * Move the focus offset `n` characters.
                *
                * @param {Number} n (optional)
                * @return {Selection}
                */
            moveEndOffset(n?: number): any;
            /**
                * Extend the focus point forward `n` characters.
                *
                * @param {Number} n (optional)
                * @return {Selection}
                */
            extendForward(n?: number): any;
            /**
                * Extend the focus point backward `n` characters.
                *
                * @param {Number} n (optional)
                * @return {Selection}
                */
            extendBackward(n?: number): any;
            /**
                * Move the selection to `anchorOffset` and `focusOffset`.
                *
                * @param {Number} anchorOffset
                * @param {Number} focusOffset (optional)
                * @return {Selection}
                */
            moveToOffsets(anchorOffset: any, focusOffset?: any): any;
    }
    export default Selection;
}

declare module 'slate/models/stack' {
    const Stack_base: any;
    /**
        * Stack.
        *
        * @type {Stack}
        */
    class Stack extends Stack_base {
            /**
                * Constructor.
                *
                * @param {Object} attrs
                *   @property {Array} plugins
                *   @property {Schema|Object} schema
                *   @property {Function} ...handlers
                */
            static create(attrs?: {}): any;
            /**
                * Check if a `value` is a `Stack`.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isStack(value: any): boolean;
            /**
                * Get the kind.
                *
                * @return {String}
                */
            readonly kind: string;
            /**
                * Invoke `render` on all of the plugins in reverse, building up a tree of
                * higher-order components.
                *
                * @param {State} state
                * @param {Editor} editor
                * @param {Object} children
                * @param {Object} props
                * @return {Component}
                */
            render(state: any, editor: any, props: any): any;
            /**
                * Invoke `renderPortal` on all of the plugins, building a list of portals.
                *
                * @param {State} state
                * @param {Editor} editor
                * @return {Array}
                */
            renderPortal(state: any, editor: any): any[];
    }
    export default Stack;
}

declare module 'slate/models/state' {
    const State_base: any;
    /**
        * State.
        *
        * @type {State}
        */
    class State extends State_base {
            /**
                * Create a new `State` with `attrs`.
                *
                * @param {Object|State} attrs
                * @param {Object} options
                * @return {State}
                */
            static create(attrs?: {}, options?: {}): any;
            /**
                * Create a `State` from a JSON `object`.
                *
                * @param {Object} object
                * @param {Object} options
                *   @property {Boolean} normalize
                *   @property {Array} plugins
                * @return {State}
                */
            static fromJSON(object: any, options?: {}): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof State.fromJSON;
            /**
                * Check if a `value` is a `State`.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isState(value: any): boolean;
            /**
                * Get the kind.
                *
                * @return {String}
                */
            readonly kind: string;
            /**
                * Are there undoable events?
                *
                * @return {Boolean}
                */
            readonly hasUndos: boolean;
            /**
                * Are there redoable events?
                *
                * @return {Boolean}
                */
            readonly hasRedos: boolean;
            /**
                * Is the current selection blurred?
                *
                * @return {Boolean}
                */
            readonly isBlurred: any;
            /**
                * Is the current selection focused?
                *
                * @return {Boolean}
                */
            readonly isFocused: any;
            /**
                * Is the current selection collapsed?
                *
                * @return {Boolean}
                */
            readonly isCollapsed: any;
            /**
                * Is the current selection expanded?
                *
                * @return {Boolean}
                */
            readonly isExpanded: any;
            /**
                * Is the current selection backward?
                *
                * @return {Boolean} isBackward
                */
            readonly isBackward: any;
            /**
                * Is the current selection forward?
                *
                * @return {Boolean}
                */
            readonly isForward: any;
            /**
                * Get the current start key.
                *
                * @return {String}
                */
            readonly startKey: any;
            /**
                * Get the current end key.
                *
                * @return {String}
                */
            readonly endKey: any;
            /**
                * Get the current start offset.
                *
                * @return {String}
                */
            readonly startOffset: any;
            /**
                * Get the current end offset.
                *
                * @return {String}
                */
            readonly endOffset: any;
            /**
                * Get the current anchor key.
                *
                * @return {String}
                */
            readonly anchorKey: any;
            /**
                * Get the current focus key.
                *
                * @return {String}
                */
            readonly focusKey: any;
            /**
                * Get the current anchor offset.
                *
                * @return {String}
                */
            readonly anchorOffset: any;
            /**
                * Get the current focus offset.
                *
                * @return {String}
                */
            readonly focusOffset: any;
            /**
                * Get the current start text node's closest block parent.
                *
                * @return {Block}
                */
            readonly startBlock: any;
            /**
                * Get the current end text node's closest block parent.
                *
                * @return {Block}
                */
            readonly endBlock: any;
            /**
                * Get the current anchor text node's closest block parent.
                *
                * @return {Block}
                */
            readonly anchorBlock: any;
            /**
                * Get the current focus text node's closest block parent.
                *
                * @return {Block}
                */
            readonly focusBlock: any;
            /**
                * Get the current start text node's closest inline parent.
                *
                * @return {Inline}
                */
            readonly startInline: any;
            /**
                * Get the current end text node's closest inline parent.
                *
                * @return {Inline}
                */
            readonly endInline: any;
            /**
                * Get the current anchor text node's closest inline parent.
                *
                * @return {Inline}
                */
            readonly anchorInline: any;
            /**
                * Get the current focus text node's closest inline parent.
                *
                * @return {Inline}
                */
            readonly focusInline: any;
            /**
                * Get the current start text node.
                *
                * @return {Text}
                */
            readonly startText: any;
            /**
                * Get the current end node.
                *
                * @return {Text}
                */
            readonly endText: any;
            /**
                * Get the current anchor node.
                *
                * @return {Text}
                */
            readonly anchorText: any;
            /**
                * Get the current focus node.
                *
                * @return {Text}
                */
            readonly focusText: any;
            /**
                * Get the characters in the current selection.
                *
                * @return {List<Character>}
                */
            readonly characters: any;
            /**
                * Get the marks of the current selection.
                *
                * @return {Set<Mark>}
                */
            readonly marks: any;
            /**
                * Get the active marks of the current selection.
                *
                * @return {Set<Mark>}
                */
            readonly activeMarks: any;
            /**
                * Get the block nodes in the current selection.
                *
                * @return {List<Block>}
                */
            readonly blocks: any;
            /**
                * Get the fragment of the current selection.
                *
                * @return {Document}
                */
            readonly fragment: any;
            /**
                * Get the inline nodes in the current selection.
                *
                * @return {List<Inline>}
                */
            readonly inlines: any;
            /**
                * Get the text nodes in the current selection.
                *
                * @return {List<Text>}
                */
            readonly texts: any;
            /**
                * Check whether the selection is empty.
                *
                * @return {Boolean}
                */
            readonly isEmpty: boolean;
            /**
                * Create a new `Change` with the current state as a starting point.
                *
                * @param {Object} attrs
                * @return {Change}
                */
            change(attrs?: {}): any;
            /**
                * Deprecated.
                *
                * @return {Change}
                */
            transform(...args: any[]): any;
            /**
                * Return a JSON representation of the state.
                *
                * @param {Object} options
                * @return {Object}
                */
            toJSON(options?: {}): {
                    data: any;
                    document: any;
                    kind: string;
                    history: any;
                    selection: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(options: any): {
                    data: any;
                    document: any;
                    kind: string;
                    history: any;
                    selection: any;
            };
    }
    export default State;
}

declare module 'slate/models/text' {
    const Text_base: any;
    /**
        * Text.
        *
        * @type {Text}
        */
    class Text extends Text_base {
            /**
                * Create a new `Text` with `attrs`.
                *
                * @param {Object|Array|List|String|Text} attrs
                * @return {Text}
                */
            static create(attrs?: {}): any;
            /**
                * Create a list of `Texts` from a `value`.
                *
                * @param {Array<Text|Object>|List<Text|Object>} value
                * @return {List<Text>}
                */
            static createList(value?: any[]): any;
            /**
                * Create a `Text` from a JSON `object`.
                *
                * @param {Object|Text} object
                * @return {Text}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Text.fromJSON;
            /**
                * Check if a `value` is a `Text`.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isText(value: any): boolean;
            /**
                * Check if a `value` is a listof texts.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isTextList(value: any): any;
            /**
                * Deprecated.
                */
            static createFromString(string: any): any;
            /**
                * Deprecated.
                */
            static createFromRanges(ranges: any): any;
            /**
                * Get the node's kind.
                *
                * @return {String}
                */
            readonly kind: string;
            /**
                * Is the node empty?
                *
                * @return {Boolean}
                */
            readonly isEmpty: boolean;
            /**
                * Get the concatenated text of the node.
                *
                * @return {String}
                */
            readonly text: any;
            /**
                * Add a `mark` at `index` and `length`.
                *
                * @param {Number} index
                * @param {Number} length
                * @param {Mark} mark
                * @return {Text}
                */
            addMark(index: any, length: any, mark: any): any;
            /**
                * Derive a set of decorated characters with `decorators`.
                *
                * @param {Array} decorators
                * @return {List<Character>}
                */
            getDecorations(decorators: any): any;
            /**
                * Get the decorations for the node from a `schema`.
                *
                * @param {Schema} schema
                * @return {Array}
                */
            getDecorators(schema: any): any;
            /**
                * Get all of the marks on the text.
                *
                * @return {OrderedSet<Mark>}
                */
            getMarks(): any;
            /**
                * Get all of the marks on the text as an array
                *
                * @return {Array}
                */
            getMarksAsArray(): any;
            /**
                * Get the marks on the text at `index`.
                *
                * @param {Number} index
                * @return {Set<Mark>}
                */
            getMarksAtIndex(index: any): any;
            /**
                * Get a node by `key`, to parallel other nodes.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getNode(key: any): this;
            /**
                * Derive the ranges for a list of `characters`.
                *
                * @param {Array|Void} decorators (optional)
                * @return {List<Range>}
                */
            getRanges(decorators?: any[]): any[];
            /**
                * Check if the node has a node by `key`, to parallel other nodes.
                *
                * @param {String} key
                * @return {Boolean}
                */
            hasNode(key: any): boolean;
            /**
                * Insert `text` at `index`.
                *
                * @param {Numbder} index
                * @param {String} text
                * @param {String} marks (optional)
                * @return {Text}
                */
            insertText(index: any, text: any, marks: any): any;
            /**
                * Regenerate the node's key.
                *
                * @return {Text}
                */
            regenerateKey(): any;
            /**
                * Remove a `mark` at `index` and `length`.
                *
                * @param {Number} index
                * @param {Number} length
                * @param {Mark} mark
                * @return {Text}
                */
            removeMark(index: any, length: any, mark: any): any;
            /**
                * Remove text from the text node at `index` for `length`.
                *
                * @param {Number} index
                * @param {Number} length
                * @return {Text}
                */
            removeText(index: any, length: any): any;
            /**
                * Return a JSON representation of the text.
                *
                * @param {Object} options
                * @return {Object}
                */
            toJSON(options?: {}): {
                    key: any;
                    kind: string;
                    ranges: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(options: any): {
                    key: any;
                    kind: string;
                    ranges: any;
            };
            /**
                * Update a `mark` at `index` and `length` with `properties`.
                *
                * @param {Number} index
                * @param {Number} length
                * @param {Mark} mark
                * @param {Object} properties
                * @return {Text}
                */
            updateMark(index: any, length: any, mark: any, properties: any): any;
            /**
                * Validate the text node against a `schema`.
                *
                * @param {Schema} schema
                * @return {Object|Void}
                */
            validate(schema: any): any;
    }
    export default Text;
}

declare module 'slate/models/range' {
    const Range_base: any;
    /**
        * Range.
        *
        * @type {Range}
        */
    class Range extends Range_base {
            /**
                * Create a new `Range` with `attrs`.
                *
                * @param {Object|Range} attrs
                * @return {Range}
                */
            static create(attrs?: {}): any;
            /**
                * Create a list of `Ranges` from `value`.
                *
                * @param {Array<Range|Object>|List<Range|Object>} value
                * @return {List<Range>}
                */
            static createList(value?: any[]): any;
            /**
                * Create a `Range` from a JSON `object`.
                *
                * @param {Object} object
                * @return {Range}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Range.fromJSON;
            /**
                * Check if a `value` is a `Range`.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isRange(value: any): boolean;
            /**
                * Check if a `value` is a list of ranges.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isRangeList(value: any): any;
            /**
                * Get the node's kind.
                *
                * @return {String}
                */
            readonly kind: string;
            /**
                * Return range as a list of characters
                *
                * @return {List<Character>}
                */
            getCharacters(): any;
            /**
                * Return a JSON representation of the range.
                *
                * @return {Object}
                */
            toJSON(): {
                    kind: string;
                    marks: any;
                    text: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(): {
                    kind: string;
                    marks: any;
                    text: any;
            };
    }
    export default Range;
}

declare module 'slate/operations' {
    const _default: {
        apply: any;
        invert: any;
    };
    export default _default;
}

declare module 'slate/changes' {
    const _default: any;
    export default _default;
}

declare module 'slate/utils/generate-key' {
    /**
        * Generate a key.
        *
        * @return {String}
        */
    function generateKey(): any;
    /**
        * Set a different unique ID generating `function`.
        *
        * @param {Function} func
        */
    function setKeyGenerator(func: any): void;
    /**
        * Reset the key generating function to its initial state.
        */
    function resetKeyGenerator(): void;
    /**
        * Export.
        *
        * @type {Object}
        */
    export { generateKey as default, setKeyGenerator, resetKeyGenerator };
}

