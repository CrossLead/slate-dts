// Generated by dts-bundle v0.7.3

declare module "slate" {
  import Block from "slate/models/block";
  import Change from "slate/models/change";
  import Changes from "slate/changes";
  import Character from "slate/models/character";
  import Data from "slate/models/data";
  import Document from "slate/models/document";
  import History from "slate/models/history";
  import Inline from "slate/models/inline";
  import Leaf from "slate/models/leaf";
  import Mark from "slate/models/mark";
  import Node from "slate/models/node";
  import Operation from "slate/models/operation";
  import Operations from "slate/operations";
  import Range from "slate/models/range";
  import Schema from "slate/models/schema";
  import Stack from "slate/models/stack";
  import Text from "slate/models/text";
  import Value from "slate/models/value";
  import { resetKeyGenerator, setKeyGenerator } from "slate/utils/generate-key";
  import { resetMemoization, useMemoization } from "slate/utils/memoize";
  /**
   * Export.
   *
   * @type {Object}
   */
  export {
    Block,
    Change,
    Changes,
    Character,
    Data,
    Document,
    History,
    Inline,
    Leaf,
    Mark,
    Node,
    Operation,
    Operations,
    Range,
    Schema,
    Stack,
    Text,
    Value,
    resetKeyGenerator,
    setKeyGenerator,
    resetMemoization,
    useMemoization
  };
  const _default: {
    Block: any;
    Changes: any;
    Character: any;
    Data: any;
    Document: any;
    History: any;
    Inline: any;
    Leaf: any;
    Mark: any;
    Node: any;
    Operation: any;
    Operations: any;
    Range: any;
    Schema: any;
    Stack: any;
    Text: any;
    Value: any;
    resetKeyGenerator: any;
    setKeyGenerator: any;
    resetMemoization: any;
    useMemoization: any;
  };
  export default _default;
}

declare module "slate/models/block" {
  /**
   * Prevent circular dependencies.
   */
  // import './document';
  const Block_base: any;
  /**
   * Block.
   *
   * @type {Block}
   */
  class Block extends Block_base {
    /**
     * Create a new `Block` from `attrs`.
     *
     * @param {Object|String|Block} attrs
     * @return {Block}
     */
    static create(attrs?: {}): any;
    /**
     * Create a list of `Blocks` from `attrs`.
     *
     * @param {Array<Block|Object>|List<Block|Object>} attrs
     * @return {List<Block>}
     */
    static createList(attrs?: any[]): any;
    /**
     * Create a `Block` from a JSON `object`.
     *
     * @param {Object|Block} object
     * @return {Block}
     */
    static fromJSON(object: any): any;
    /**
     * Alias `fromJS`.
     */
    static fromJS: typeof Block.fromJSON;
    /**
     * Check if `any` is a `Block`.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isBlock(any: any): boolean;
    /**
     * Check if `any` is a block list.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isBlockList(any: any): any;
    /**
     * Object.
     *
     * @return {String}
     */
    readonly object: string;
    readonly kind: string;
    /**
     * Check if the block is empty.
     * Returns true if block is not void and all it's children nodes are empty.
     * Void node is never empty, regardless of it's content.
     *
     * @return {Boolean}
     */
    readonly isEmpty: boolean;
    /**
     * Get the concatenated text of all the block's children.
     *
     * @return {String}
     */
    readonly text: any;
    /**
     * Return a JSON representation of the block.
     *
     * @param {Object} options
     * @return {Object}
     */
    toJSON(options?: {}): {
      object: string;
      type: any;
      isVoid: any;
      data: any;
      nodes: any;
    };
    /**
     * Alias `toJS`.
     */
    toJS(
      options: any
    ): {
      object: string;
      type: any;
      isVoid: any;
      data: any;
      nodes: any;
    };
  }
  export default Block;
}

declare module "slate/models/change" {
  /**
   * Change.
   *
   * @type {Change}
   */
  class Change {
    /**
     * Check if `any` is a `Change`.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isChange(any: any): boolean;
    /**
     * Create a new `Change` with `attrs`.
     *
     * @param {Object} attrs
     *   @property {Value} value
     */
    constructor(attrs: any);
    /**
     * Object.
     *
     * @return {String}
     */
    readonly object: string;
    readonly kind: string;
    /**
     * Apply an `operation` to the current value, saving the operation to the
     * history if needed.
     *
     * @param {Operation|Object} operation
     * @param {Object} options
     * @return {Change}
     */
    applyOperation(operation: any, options?: {}): this;
    /**
     * Apply a series of `operations` to the current value.
     *
     * @param {Array|List} operations
     * @param {Object} options
     * @return {Change}
     */
    applyOperations(operations: any, options: any): this;
    /**
     * Call a change `fn` with arguments.
     *
     * @param {Function} fn
     * @param {Mixed} ...args
     * @return {Change}
     */
    call(fn: any, ...args: any[]): this;
    /**
     * Applies a series of change mutations and defers normalization until the end.
     *
     * @param {Function} customChange - function that accepts a change object and executes change operations
     * @return {Change}
     */
    withoutNormalization(customChange: any): this;
    /**
     * Set an operation flag by `key` to `value`.
     *
     * @param {String} key
     * @param {Any} value
     * @return {Change}
     */
    setOperationFlag(key: any, value: any): this;
    /**
     * Get the `value` of the specified flag by its `key`. Optionally accepts an `options`
     * object with override flags.
     *
     * @param {String} key
     * @param {Object} options
     * @return {Change}
     */
    getFlag(key: any, options?: {}): any;
    /**
     * Unset an operation flag by `key`.
     *
     * @param {String} key
     * @return {Change}
     */
    unsetOperationFlag(key: any): this;
  }
  export default Change;
}

declare module "slate/changes" {
  const _default: any;
  export default _default;
}

declare module "slate/models/character" {
  const Character_base: any;
  /**
   * Character.
   *
   * @type {Character}
   */
  class Character extends Character_base {
    /**
     * Create a `Character` with `attrs`.
     *
     * @param {Object|String|Character} attrs
     * @return {Character}
     */
    static create(attrs?: {}): any;
    /**
     * Create a list of `Characters` from `elements`.
     *
     * @param {String|Array<Object|Character|String>|List<Object|Character|String>} elements
     * @return {List<Character>}
     */
    static createList(elements?: any[]): any;
    /**
     * Create a `Character` from a JSON `object`.
     *
     * @param {Object} object
     * @return {Character}
     */
    static fromJSON(object: any): any;
    /**
     * Alias `fromJS`.
     */
    static fromJS: typeof Character.fromJSON;
    /**
     * Check if `any` is a `Character`.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isCharacter(any: any): boolean;
    /**
     * Check if `any` is a character list.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isCharacterList(any: any): any;
    /**
     * Object.
     *
     * @return {String}
     */
    readonly object: string;
    readonly kind: string;
    /**
     * Return a JSON representation of the character.
     *
     * @return {Object}
     */
    toJSON(): {
      object: string;
      text: any;
      marks: any;
    };
    /**
     * Alias `toJS`.
     */
    toJS(): {
      object: string;
      text: any;
      marks: any;
    };
  }
  export default Character;
}

declare module "slate/models/data" {
  /**
   * Data.
   *
   * This isn't an immutable record, it's just a thin wrapper around `Map` so that
   * we can allow for more convenient creation.
   *
   * @type {Object}
   */
  class Data {
    /**
     * Create a new `Data` with `attrs`.
     *
     * @param {Object|Data|Map} attrs
     * @return {Data} data
     */
    static create(attrs?: {}): any;
    /**
     * Create a `Data` from a JSON `object`.
     *
     * @param {Object} object
     * @return {Data}
     */
    static fromJSON(object: any): any;
    /**
     * Alias `fromJS`.
     */
    static fromJS: typeof Data.fromJSON;
  }
  export default Data;
}

declare module "slate/models/document" {
  /**
   * Prevent circular dependencies.
   */
  // import './block';
  // import './inline';
  const Document_base: any;
  /**
   * Document.
   *
   * @type {Document}
   */
  class Document extends Document_base {
    /**
     * Create a new `Document` with `attrs`.
     *
     * @param {Object|Array|List|Text} attrs
     * @return {Document}
     */
    static create(attrs?: {}): any;
    /**
     * Create a `Document` from a JSON `object`.
     *
     * @param {Object|Document} object
     * @return {Document}
     */
    static fromJSON(object: any): any;
    /**
     * Alias `fromJS`.
     */
    static fromJS: typeof Document.fromJSON;
    /**
     * Check if `any` is a `Document`.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isDocument(any: any): boolean;
    /**
     * Object.
     *
     * @return {String}
     */
    readonly object: string;
    readonly kind: string;
    /**
     * Check if the document is empty.
     * Returns true if all it's children nodes are empty.
     *
     * @return {Boolean}
     */
    readonly isEmpty: boolean;
    /**
     * Get the concatenated text of all the document's children.
     *
     * @return {String}
     */
    readonly text: any;
    /**
     * Return a JSON representation of the document.
     *
     * @param {Object} options
     * @return {Object}
     */
    toJSON(options?: {}): {
      object: string;
      data: any;
      nodes: any;
    };
    /**
     * Alias `toJS`.
     */
    toJS(
      options: any
    ): {
      object: string;
      data: any;
      nodes: any;
    };
  }
  export default Document;
}

declare module "slate/models/history" {
  const History_base: any;
  /**
   * History.
   *
   * @type {History}
   */
  class History extends History_base {
    /**
     * Create a new `History` with `attrs`.
     *
     * @param {Object|History} attrs
     * @return {History}
     */
    static create(attrs?: {}): any;
    /**
     * Create a `History` from a JSON `object`.
     *
     * @param {Object} object
     * @return {History}
     */
    static fromJSON(object: any): any;
    /**
     * Alias `fromJS`.
     */
    static fromJS: typeof History.fromJSON;
    /**
     * Check if `any` is a `History`.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isHistory(any: any): boolean;
    /**
     * Object.
     *
     * @return {String}
     */
    readonly object: string;
    readonly kind: string;
    /**
     * Save an `operation` into the history.
     *
     * @param {Object} operation
     * @param {Object} options
     * @return {History}
     */
    save(operation: any, options?: {}): this;
    /**
     * Return a JSON representation of the history.
     *
     * @return {Object}
     */
    toJSON(): {
      object: string;
      redos: any;
      undos: any;
    };
    /**
     * Alias `toJS`.
     */
    toJS(): {
      object: string;
      redos: any;
      undos: any;
    };
  }
  export default History;
}

declare module "slate/models/inline" {
  /**
   * Prevent circular dependencies.
   */
  // import './document';
  const Inline_base: any;
  /**
   * Inline.
   *
   * @type {Inline}
   */
  class Inline extends Inline_base {
    /**
     * Create a new `Inline` with `attrs`.
     *
     * @param {Object|String|Inline} attrs
     * @return {Inline}
     */
    static create(attrs?: {}): any;
    /**
     * Create a list of `Inlines` from an array.
     *
     * @param {Array<Inline|Object>|List<Inline|Object>} elements
     * @return {List<Inline>}
     */
    static createList(elements?: any[]): any;
    /**
     * Create a `Inline` from a JSON `object`.
     *
     * @param {Object|Inline} object
     * @return {Inline}
     */
    static fromJSON(object: any): any;
    /**
     * Alias `fromJS`.
     */
    static fromJS: typeof Inline.fromJSON;
    /**
     * Check if `any` is a `Inline`.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isInline(any: any): boolean;
    /**
     * Check if `any` is a list of inlines.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isInlineList(any: any): any;
    /**
     * Object.
     *
     * @return {String}
     */
    readonly object: string;
    readonly kind: string;
    /**
     * Check if the inline is empty.
     * Returns true if inline is not void and all it's children nodes are empty.
     * Void node is never empty, regardless of it's content.
     *
     * @return {Boolean}
     */
    readonly isEmpty: boolean;
    /**
     * Get the concatenated text of all the inline's children.
     *
     * @return {String}
     */
    readonly text: any;
    /**
     * Return a JSON representation of the inline.
     *
     * @param {Object} options
     * @return {Object}
     */
    toJSON(options?: {}): {
      object: string;
      type: any;
      isVoid: any;
      data: any;
      nodes: any;
    };
    /**
     * Alias `toJS`.
     */
    toJS(
      options: any
    ): {
      object: string;
      type: any;
      isVoid: any;
      data: any;
      nodes: any;
    };
  }
  export default Inline;
}

declare module "slate/models/leaf" {
  const Leaf_base: any;
  /**
   * Leaf.
   *
   * @type {Leaf}
   */
  class Leaf extends Leaf_base {
    /**
     * Create a new `Leaf` with `attrs`.
     *
     * @param {Object|Leaf} attrs
     * @return {Leaf}
     */
    static create(attrs?: {}): any;
    /**
     * Create a `Leaf` list from `attrs`.
     *
     * @param {Array<Leaf|Object>|List<Leaf|Object>} attrs
     * @return {List<Leaf>}
     */
    static createList(attrs?: any[]): any;
    /**
     * Create a `Leaf` from a JSON `object`.
     *
     * @param {Object} object
     * @return {Leaf}
     */
    static fromJSON(object: any): any;
    /**
     * Alias `fromJS`.
     */
    static fromJS: typeof Leaf.fromJSON;
    /**
     * Check if `any` is a `Leaf`.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isLeaf(any: any): boolean;
    /**
     * Check if `any` is a list of leaves.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isLeafList(any: any): any;
    /**
     * Object.
     *
     * @return {String}
     */
    readonly object: string;
    readonly kind: string;
    /**
     * Return leaf as a list of characters
     *
     * @return {List<Character>}
     */
    getCharacters(): any;
    /**
     * Return a JSON representation of the leaf.
     *
     * @return {Object}
     */
    toJSON(): {
      object: string;
      text: any;
      marks: any;
    };
    /**
     * Alias `toJS`.
     */
    toJS(): {
      object: string;
      text: any;
      marks: any;
    };
  }
  export default Leaf;
}

declare module "slate/models/mark" {
  const Mark_base: any;
  /**
   * Mark.
   *
   * @type {Mark}
   */
  class Mark extends Mark_base {
    /**
     * Create a new `Mark` with `attrs`.
     *
     * @param {Object|Mark} attrs
     * @return {Mark}
     */
    static create(attrs?: {}): any;
    /**
     * Create a set of marks.
     *
     * @param {Array<Object|Mark>} elements
     * @return {Set<Mark>}
     */
    static createSet(elements: any): any;
    /**
     * Create a dictionary of settable mark properties from `attrs`.
     *
     * @param {Object|String|Mark} attrs
     * @return {Object}
     */
    static createProperties(attrs?: {}):
      | {}
      | {
          data: any;
          type: any;
        }
      | {
          type: string;
        };
    /**
     * Create a `Mark` from a JSON `object`.
     *
     * @param {Object} object
     * @return {Mark}
     */
    static fromJSON(object: any): any;
    /**
     * Alias `fromJS`.
     */
    static fromJS: typeof Mark.fromJSON;
    /**
     * Check if `any` is a `Mark`.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isMark(any: any): boolean;
    /**
     * Check if `any` is a set of marks.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isMarkSet(any: any): any;
    /**
     * Object.
     */
    readonly object: string;
    readonly kind: string;
    /**
     * Get the component for the node from a `schema`.
     *
     * @param {Schema} schema
     * @return {Component|Void}
     */
    getComponent(schema: any): any;
    /**
     * Return a JSON representation of the mark.
     *
     * @return {Object}
     */
    toJSON(): {
      object: string;
      type: any;
      data: any;
    };
    /**
     * Alias `toJS`.
     */
    toJS(): {
      object: string;
      type: any;
      data: any;
    };
  }
  export default Mark;
}

declare module "slate/models/node" {
  /**
   * Node.
   *
   * And interface that `Document`, `Block` and `Inline` all implement, to make
   * working with the recursive node tree easier.
   *
   * @type {Node}
   */
  class Node {
    /**
     * Create a new `Node` with `attrs`.
     *
     * @param {Object|Node} attrs
     * @return {Node}
     */
    static create(attrs?: {}): any;
    /**
     * Create a list of `Nodes` from an array.
     *
     * @param {Array<Object|Node>} elements
     * @return {List<Node>}
     */
    static createList(elements?: any[]): any;
    /**
     * Create a dictionary of settable node properties from `attrs`.
     *
     * @param {Object|String|Node} attrs
     * @return {Object}
     */
    static createProperties(attrs?: {}):
      | {}
      | {
          data: any;
          isVoid: any;
          type: any;
        }
      | {
          type: string;
        };
    /**
     * Create a `Node` from a JSON `value`.
     *
     * @param {Object} value
     * @return {Node}
     */
    static fromJSON(value: any): any;
    /**
     * Alias `fromJS`.
     */
    static fromJS: typeof Node.fromJSON;
    /**
     * Check if `any` is a `Node`.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isNode(any: any): any;
    /**
     * Check if `any` is a list of nodes.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isNodeList(any: any): any;
    /**
     * True if the node has both descendants in that order, false otherwise. The
     * order is depth-first, post-order.
     *
     * @param {String} first
     * @param {String} second
     * @return {Boolean}
     */
    areDescendantsSorted(first: any, second: any): boolean;
    /**
     * Assert that a node has a child by `key` and return it.
     *
     * @param {String} key
     * @return {Node}
     */
    assertChild(key: any): any;
    /**
     * Assert that a node has a descendant by `key` and return it.
     *
     * @param {String} key
     * @return {Node}
     */
    assertDescendant(key: any): any;
    /**
     * Assert that a node's tree has a node by `key` and return it.
     *
     * @param {String} key
     * @return {Node}
     */
    assertNode(key: any): any;
    /**
     * Assert that a node exists at `path` and return it.
     *
     * @param {Array} path
     * @return {Node}
     */
    assertPath(path: any): this;
    /**
     * Recursively filter all descendant nodes with `iterator`.
     *
     * @param {Function} iterator
     * @return {List<Node>}
     */
    filterDescendants(iterator: any): any;
    /**
     * Recursively find all descendant nodes by `iterator`.
     *
     * @param {Function} iterator
     * @return {Node|Null}
     */
    findDescendant(iterator: any): any;
    /**
     * Recursively iterate over all descendant nodes with `iterator`. If the
     * iterator returns false it will break the loop.
     *
     * @param {Function} iterator
     */
    forEachDescendant(iterator: any): any;
    /**
     * Get the path of ancestors of a descendant node by `key`.
     *
     * @param {String|Node} key
     * @return {List<Node>|Null}
     */
    getAncestors(key: any): any;
    /**
     * Get the leaf block descendants of the node.
     *
     * @return {List<Node>}
     */
    getBlocks(): any;
    /**
     * Get the leaf block descendants of the node.
     *
     * @return {List<Node>}
     */
    getBlocksAsArray(): any;
    /**
     * Get the leaf block descendants in a `range`.
     *
     * @param {Range} range
     * @return {List<Node>}
     */
    getBlocksAtRange(range: any): any;
    /**
     * Get the leaf block descendants in a `range` as an array
     *
     * @param {Range} range
     * @return {Array}
     */
    getBlocksAtRangeAsArray(range: any): any;
    /**
     * Get all of the leaf blocks that match a `type`.
     *
     * @param {String} type
     * @return {List<Node>}
     */
    getBlocksByType(type: any): any;
    /**
     * Get all of the leaf blocks that match a `type` as an array
     *
     * @param {String} type
     * @return {Array}
     */
    getBlocksByTypeAsArray(type: any): any;
    /**
     * Get all of the characters for every text node.
     *
     * @return {List<Character>}
     */
    getCharacters(): any;
    /**
     * Get all of the characters for every text node as an array
     *
     * @return {Array}
     */
    getCharactersAsArray(): any;
    /**
     * Get a list of the characters in a `range`.
     *
     * @param {Range} range
     * @return {List<Character>}
     */
    getCharactersAtRange(range: any): any;
    /**
     * Get a list of the characters in a `range` as an array.
     *
     * @param {Range} range
     * @return {Array}
     */
    getCharactersAtRangeAsArray(range: any): any;
    /**
     * Get a child node by `key`.
     *
     * @param {String} key
     * @return {Node|Null}
     */
    getChild(key: any): any;
    /**
     * Get closest parent of node by `key` that matches `iterator`.
     *
     * @param {String} key
     * @param {Function} iterator
     * @return {Node|Null}
     */
    getClosest(key: any, iterator: any): any;
    /**
     * Get the closest block parent of a `node`.
     *
     * @param {String} key
     * @return {Node|Null}
     */
    getClosestBlock(key: any): any;
    /**
     * Get the closest inline parent of a `node`.
     *
     * @param {String} key
     * @return {Node|Null}
     */
    getClosestInline(key: any): any;
    /**
     * Get the closest void parent of a `node`.
     *
     * @param {String} key
     * @return {Node|Null}
     */
    getClosestVoid(key: any): any;
    /**
     * Get the common ancestor of nodes `one` and `two` by keys.
     *
     * @param {String} one
     * @param {String} two
     * @return {Node}
     */
    getCommonAncestor(one: any, two: any): any;
    /**
     * Get the decorations for the node from a `stack`.
     *
     * @param {Stack} stack
     * @return {List}
     */
    getDecorations(stack: any): any;
    /**
     * Get the depth of a child node by `key`, with optional `startAt`.
     *
     * @param {String} key
     * @param {Number} startAt (optional)
     * @return {Number} depth
     */
    getDepth(key: any, startAt?: number): any;
    /**
     * Get a descendant node by `key`.
     *
     * @param {String} key
     * @return {Node|Null}
     */
    getDescendant(key: any): any;
    /**
     * Get a descendant by `path`.
     *
     * @param {Array} path
     * @return {Node|Null}
     */
    getDescendantAtPath(path: any): this;
    /**
     * Get the first child text node.
     *
     * @return {Node|Null}
     */
    getFirstText(): any;
    /**
     * Get a fragment of the node at a `range`.
     *
     * @param {Range} range
     * @return {Document}
     */
    getFragmentAtRange(range: any): any;
    /**
     * Get the furthest parent of a node by `key` that matches an `iterator`.
     *
     * @param {String} key
     * @param {Function} iterator
     * @return {Node|Null}
     */
    getFurthest(key: any, iterator: any): any;
    /**
     * Get the furthest block parent of a node by `key`.
     *
     * @param {String} key
     * @return {Node|Null}
     */
    getFurthestBlock(key: any): any;
    /**
     * Get the furthest inline parent of a node by `key`.
     *
     * @param {String} key
     * @return {Node|Null}
     */
    getFurthestInline(key: any): any;
    /**
     * Get the furthest ancestor of a node by `key`.
     *
     * @param {String} key
     * @return {Node|Null}
     */
    getFurthestAncestor(key: any): any;
    /**
     * Get the furthest ancestor of a node by `key` that has only one child.
     *
     * @param {String} key
     * @return {Node|Null}
     */
    getFurthestOnlyChildAncestor(key: any): any;
    /**
     * Get the closest inline nodes for each text node in the node.
     *
     * @return {List<Node>}
     */
    getInlines(): any;
    /**
     * Get the closest inline nodes for each text node in the node, as an array.
     *
     * @return {List<Node>}
     */
    getInlinesAsArray(): any[];
    /**
     * Get the closest inline nodes for each text node in a `range`.
     *
     * @param {Range} range
     * @return {List<Node>}
     */
    getInlinesAtRange(range: any): any;
    /**
     * Get the closest inline nodes for each text node in a `range` as an array.
     *
     * @param {Range} range
     * @return {Array}
     */
    getInlinesAtRangeAsArray(range: any): any[];
    /**
     * Get all of the leaf inline nodes that match a `type`.
     *
     * @param {String} type
     * @return {List<Node>}
     */
    getInlinesByType(type: any): any;
    /**
     * Get all of the leaf inline nodes that match a `type` as an array.
     *
     * @param {String} type
     * @return {Array}
     */
    getInlinesByTypeAsArray(type: any): any;
    /**
     * Return a set of all keys in the node as an array.
     *
     * @return {Array<String>}
     */
    getKeysAsArray(): any[];
    /**
     * Return a set of all keys in the node.
     *
     * @return {Set<String>}
     */
    getKeys(): any;
    /**
     * Get the last child text node.
     *
     * @return {Node|Null}
     */
    getLastText(): any;
    /**
     * Get all of the marks for all of the characters of every text node.
     *
     * @return {Set<Mark>}
     */
    getMarks(): any;
    /**
     * Get all of the marks for all of the characters of every text node.
     *
     * @return {OrderedSet<Mark>}
     */
    getOrderedMarks(): any;
    /**
     * Get all of the marks as an array.
     *
     * @return {Array}
     */
    getMarksAsArray(): any;
    /**
     * Get a set of the marks in a `range`.
     *
     * @param {Range} range
     * @return {Set<Mark>}
     */
    getMarksAtRange(range: any): any;
    /**
     * Get a set of the marks in a `range`.
     *
     * @param {Range} range
     * @return {Set<Mark>}
     */
    getInsertMarksAtRange(range: any): any;
    /**
     * Get a set of the marks in a `range`.
     *
     * @param {Range} range
     * @return {OrderedSet<Mark>}
     */
    getOrderedMarksAtRange(range: any): any;
    /**
     * Get a set of the active marks in a `range`.
     *
     * @param {Range} range
     * @return {Set<Mark>}
     */
    getActiveMarksAtRange(range: any): any;
    /**
     * Get a set of the marks in a `range`, by unioning.
     *
     * @param {Range} range
     * @return {Array}
     */
    getMarksAtRangeAsArray(range: any): any;
    /**
     * Get a set of the marks in a `range` for insertion behavior.
     *
     * @param {Range} range
     * @return {Array}
     */
    getInsertMarksAtRangeAsArray(range: any): any;
    /**
     * Get a set of marks in a `range`, by treating it as collapsed.
     *
     * @param {Range} range
     * @return {Array}
     */
    getMarksAtCollapsedRangeAsArray(range: any): any;
    /**
     * Get a set of marks in a `range`, by intersecting.
     *
     * @param {Range} range
     * @return {Array}
     */
    getActiveMarksAtRangeAsArray(range: any): any;
    /**
     * Get all of the marks that match a `type`.
     *
     * @param {String} type
     * @return {Set<Mark>}
     */
    getMarksByType(type: any): any;
    /**
     * Get all of the marks that match a `type`.
     *
     * @param {String} type
     * @return {OrderedSet<Mark>}
     */
    getOrderedMarksByType(type: any): any;
    /**
     * Get all of the marks that match a `type` as an array.
     *
     * @param {String} type
     * @return {Array}
     */
    getMarksByTypeAsArray(type: any): any;
    /**
     * Get the block node before a descendant text node by `key`.
     *
     * @param {String} key
     * @return {Node|Null}
     */
    getNextBlock(key: any): any;
    /**
     * Get the node after a descendant by `key`.
     *
     * @param {String} key
     * @return {Node|Null}
     */
    getNextSibling(key: any): any;
    /**
     * Get the text node after a descendant text node by `key`.
     *
     * @param {String} key
     * @return {Node|Null}
     */
    getNextText(key: any): any;
    /**
     * Get a node in the tree by `key`.
     *
     * @param {String} key
     * @return {Node|Null}
     */
    getNode(key: any): any;
    /**
     * Get a node in the tree by `path`.
     *
     * @param {Array} path
     * @return {Node|Null}
     */
    getNodeAtPath(path: any): this;
    /**
     * Get the offset for a descendant text node by `key`.
     *
     * @param {String} key
     * @return {Number}
     */
    getOffset(key: any): any;
    /**
     * Get the offset from a `range`.
     *
     * @param {Range} range
     * @return {Number}
     */
    getOffsetAtRange(range: any): any;
    /**
     * Get the parent of a child node by `key`.
     *
     * @param {String} key
     * @return {Node|Null}
     */
    getParent(key: any): any;
    /**
     * Get the path of a descendant node by `key`.
     *
     * @param {String|Node} key
     * @return {Array}
     */
    getPath(key: any): any[];
    /**
     * Refind the path of node if path is changed.
     *
     * @param {Array} path
     * @param {String} key
     * @return {Array}
     */
    refindPath(path: any, key: any): any;
    /**
     *
     * Refind the node with the same node.key after change.
     *
     * @param {Array} path
     * @param {String} key
     * @return {Node|Void}
     */
    refindNode(path: any, key: any): any;
    /**
     * Get the placeholder for the node from a `schema`.
     *
     * @param {Schema} schema
     * @return {Component|Void}
     */
    getPlaceholder(schema: any): any;
    /**
     * Get the block node before a descendant text node by `key`.
     *
     * @param {String} key
     * @return {Node|Null}
     */
    getPreviousBlock(key: any): any;
    /**
     * Get the node before a descendant node by `key`.
     *
     * @param {String} key
     * @return {Node|Null}
     */
    getPreviousSibling(key: any): any;
    /**
     * Get the text node before a descendant text node by `key`.
     *
     * @param {String} key
     * @return {Node|Null}
     */
    getPreviousText(key: any): any;
    /**
     * Get the indexes of the selection for a `range`, given an extra flag for
     * whether the node `isSelected`, to determine whether not finding matches
     * means everything is selected or nothing is.
     *
     * @param {Range} range
     * @param {Boolean} isSelected
     * @return {Object|Null}
     */
    getSelectionIndexes(
      range: any,
      isSelected?: boolean
    ): {
      start: any;
      end: any;
    };
    /**
     * Get the concatenated text string of all child nodes.
     *
     * @return {String}
     */
    getText(): any;
    /**
     * Get the descendent text node at an `offset`.
     *
     * @param {String} offset
     * @return {Node|Null}
     */
    getTextAtOffset(offset: any): any;
    /**
     * Get the direction of the node's text.
     *
     * @return {String}
     */
    getTextDirection(): any;
    /**
     * Recursively get all of the child text nodes in order of appearance.
     *
     * @return {List<Node>}
     */
    getTexts(): any;
    /**
     * Recursively get all the leaf text nodes in order of appearance, as array.
     *
     * @return {List<Node>}
     */
    getTextsAsArray(): any[];
    /**
     * Get all of the text nodes in a `range`.
     *
     * @param {Range} range
     * @return {List<Node>}
     */
    getTextsAtRange(range: any): any;
    /**
     * Get all of the text nodes in a `range` as an array.
     *
     * @param {Range} range
     * @return {Array}
     */
    getTextsAtRangeAsArray(range: any): any[];
    /**
     * Check if a child node exists by `key`.
     *
     * @param {String} key
     * @return {Boolean}
     */
    hasChild(key: any): boolean;
    /**
     * Recursively check if a child node exists by `key`.
     *
     * @param {String} key
     * @return {Boolean}
     */
    hasDescendant(key: any): boolean;
    /**
     * Recursively check if a node exists by `key`.
     *
     * @param {String} key
     * @return {Boolean}
     */
    hasNode(key: any): boolean;
    /**
     * Check if a node has a void parent by `key`.
     *
     * @param {String} key
     * @return {Boolean}
     */
    hasVoidParent(key: any): boolean;
    /**
     * Insert a `node` at `index`.
     *
     * @param {Number} index
     * @param {Node} node
     * @return {Node}
     */
    insertNode(index: any, node: any): any;
    /**
     * Check whether the node is in a `range`.
     *
     * @param {Range} range
     * @return {Boolean}
     */
    isInRange(range: any): boolean;
    /**
     * Check whether the node is a leaf block.
     *
     * @return {Boolean}
     */
    isLeafBlock(): any;
    /**
     * Check whether the node is a leaf inline.
     *
     * @return {Boolean}
     */
    isLeafInline(): any;
    /**
     * Merge a children node `first` with another children node `second`.
     * `first` and `second` will be concatenated in that order.
     * `first` and `second` must be two Nodes or two Text.
     *
     * @param {Node} first
     * @param {Node} second
     * @return {Node}
     */
    mergeNode(withIndex: any, index: any): this;
    /**
     * Map all child nodes, updating them in their parents. This method is
     * optimized to not return a new node if no changes are made.
     *
     * @param {Function} iterator
     * @return {Node}
     */
    mapChildren(iterator: any): any;
    /**
     * Map all descendant nodes, updating them in their parents. This method is
     * optimized to not return a new node if no changes are made.
     *
     * @param {Function} iterator
     * @return {Node}
     */
    mapDescendants(iterator: any): any;
    /**
     * Regenerate the node's key.
     *
     * @return {Node}
     */
    regenerateKey(): any;
    /**
     * Remove a `node` from the children node map.
     *
     * @param {String} key
     * @return {Node}
     */
    removeDescendant(key: any): this;
    /**
     * Remove a node at `index`.
     *
     * @param {Number} index
     * @return {Node}
     */
    removeNode(index: any): any;
    /**
     * Split a child node by `index` at `position`.
     *
     * @param {Number} index
     * @param {Number} position
     * @return {Node}
     */
    splitNode(index: any, position: any): this;
    /**
     * Set a new value for a child node by `key`.
     *
     * @param {Node} node
     * @return {Node}
     */
    updateNode(node: any): any;
    /**
     * Validate the node against a `schema`.
     *
     * @param {Schema} schema
     * @return {Function|Null}
     */
    validate(schema: any): any;
    /**
     * Get the first invalid descendant
     *
     * @param {Schema} schema
     * @return {Node|Text|Null}
     */
    getFirstInvalidDescendant(schema: any): any;
  }
  export default Node;
}

declare module "slate/models/operation" {
  const Operation_base: any;
  /**
   * Operation.
   *
   * @type {Operation}
   */
  class Operation extends Operation_base {
    /**
     * Create a new `Operation` with `attrs`.
     *
     * @param {Object|Array|List|String|Operation} attrs
     * @return {Operation}
     */
    static create(attrs?: {}): any;
    /**
     * Create a list of `Operations` from `elements`.
     *
     * @param {Array<Operation|Object>|List<Operation|Object>} elements
     * @return {List<Operation>}
     */
    static createList(elements?: any[]): any;
    /**
     * Create a `Operation` from a JSON `object`.
     *
     * @param {Object|Operation} object
     * @return {Operation}
     */
    static fromJSON(object: any): any;
    /**
     * Alias `fromJS`.
     */
    static fromJS: typeof Operation.fromJSON;
    /**
     * Check if `any` is a `Operation`.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isOperation(any: any): boolean;
    /**
     * Check if `any` is a list of operations.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isOperationList(any: any): any;
    /**
     * Object.
     *
     * @return {String}
     */
    readonly object: string;
    readonly kind: string;
    /**
     * Return a JSON representation of the operation.
     *
     * @param {Object} options
     * @return {Object}
     */
    toJSON(options?: {}): {
      object: string;
      type: any;
    };
    /**
     * Alias `toJS`.
     */
    toJS(
      options: any
    ): {
      object: string;
      type: any;
    };
  }
  export default Operation;
}

declare module "slate/operations" {
  const _default: {
    apply: any;
    invert: any;
  };
  export default _default;
}

declare module "slate/models/range" {
  const Range_base: any;
  /**
   * Range.
   *
   * @type {Range}
   */
  class Range extends Range_base {
    /**
     * Create a new `Range` with `attrs`.
     *
     * @param {Object|Range} attrs
     * @return {Range}
     */
    static create(attrs?: {}): any;
    /**
     * Create a list of `Ranges` from `elements`.
     *
     * @param {Array<Range|Object>|List<Range|Object>} elements
     * @return {List<Range>}
     */
    static createList(elements?: any[]): any;
    /**
     * Create a dictionary of settable range properties from `attrs`.
     *
     * @param {Object|String|Range} attrs
     * @return {Object}
     */
    static createProperties(attrs?: {}):
      | {}
      | {
          anchorKey: any;
          anchorOffset: any;
          focusKey: any;
          focusOffset: any;
          isBackward: any;
          isFocused: any;
          marks: any;
        };
    /**
     * Create a `Range` from a JSON `object`.
     *
     * @param {Object} object
     * @return {Range}
     */
    static fromJSON(object: any): any;
    /**
     * Alias `fromJS`.
     */
    static fromJS: typeof Range.fromJSON;
    /**
     * Check if an `obj` is a `Range`.
     *
     * @param {Any} obj
     * @return {Boolean}
     */
    static isRange(obj: any): boolean;
    /**
     * Object.
     *
     * @return {String}
     */
    readonly object: string;
    readonly kind: string;
    /**
     * Check whether the range is blurred.
     *
     * @return {Boolean}
     */
    readonly isBlurred: boolean;
    /**
     * Check whether the range is collapsed.
     *
     * @return {Boolean}
     */
    readonly isCollapsed: boolean;
    /**
     * Check whether the range is expanded.
     *
     * @return {Boolean}
     */
    readonly isExpanded: boolean;
    /**
     * Check whether the range is forward.
     *
     * @return {Boolean}
     */
    readonly isForward: boolean;
    /**
     * Check whether the range's keys are set.
     *
     * @return {Boolean}
     */
    readonly isSet: boolean;
    /**
     * Check whether the range's keys are not set.
     *
     * @return {Boolean}
     */
    readonly isUnset: boolean;
    /**
     * Get the start key.
     *
     * @return {String}
     */
    readonly startKey: any;
    /**
     * Get the start offset.
     *
     * @return {String}
     */
    readonly startOffset: any;
    /**
     * Get the end key.
     *
     * @return {String}
     */
    readonly endKey: any;
    /**
     * Get the end offset.
     *
     * @return {String}
     */
    readonly endOffset: any;
    /**
     * Check whether anchor point of the range is at the start of a `node`.
     *
     * @param {Node} node
     * @return {Boolean}
     */
    hasAnchorAtStartOf(node: any): boolean;
    /**
     * Check whether anchor point of the range is at the end of a `node`.
     *
     * @param {Node} node
     * @return {Boolean}
     */
    hasAnchorAtEndOf(node: any): boolean;
    /**
     * Check whether the anchor edge of a range is in a `node` and at an
     * offset between `start` and `end`.
     *
     * @param {Node} node
     * @param {Number} start
     * @param {Number} end
     * @return {Boolean}
     */
    hasAnchorBetween(node: any, start: any, end: any): any;
    /**
     * Check whether the anchor edge of a range is in a `node`.
     *
     * @param {Node} node
     * @return {Boolean}
     */
    hasAnchorIn(node: any): any;
    /**
     * Check whether focus point of the range is at the end of a `node`.
     *
     * @param {Node} node
     * @return {Boolean}
     */
    hasFocusAtEndOf(node: any): boolean;
    /**
     * Check whether focus point of the range is at the start of a `node`.
     *
     * @param {Node} node
     * @return {Boolean}
     */
    hasFocusAtStartOf(node: any): boolean;
    /**
     * Check whether the focus edge of a range is in a `node` and at an
     * offset between `start` and `end`.
     *
     * @param {Node} node
     * @param {Number} start
     * @param {Number} end
     * @return {Boolean}
     */
    hasFocusBetween(node: any, start: any, end: any): any;
    /**
     * Check whether the focus edge of a range is in a `node`.
     *
     * @param {Node} node
     * @return {Boolean}
     */
    hasFocusIn(node: any): any;
    /**
     * Check whether the range is at the start of a `node`.
     *
     * @param {Node} node
     * @return {Boolean}
     */
    isAtStartOf(node: any): boolean;
    /**
     * Check whether the range is at the end of a `node`.
     *
     * @param {Node} node
     * @return {Boolean}
     */
    isAtEndOf(node: any): boolean;
    /**
     * Focus the range.
     *
     * @return {Range}
     */
    focus(): any;
    /**
     * Blur the range.
     *
     * @return {Range}
     */
    blur(): any;
    /**
     * Unset the range.
     *
     * @return {Range}
     */
    deselect(): any;
    /**
     * Flip the range.
     *
     * @return {Range}
     */
    flip(): any;
    /**
     * Move the anchor offset `n` characters.
     *
     * @param {Number} n (optional)
     * @return {Range}
     */
    moveAnchor(n?: number): any;
    /**
     * Move the anchor offset `n` characters.
     *
     * @param {Number} n (optional)
     * @return {Range}
     */
    moveFocus(n?: number): any;
    /**
     * Move the range's anchor point to a `key` and `offset`.
     *
     * @param {String} key
     * @param {Number} offset
     * @return {Range}
     */
    moveAnchorTo(key: any, offset: any): any;
    /**
     * Move the range's focus point to a `key` and `offset`.
     *
     * @param {String} key
     * @param {Number} offset
     * @return {Range}
     */
    moveFocusTo(key: any, offset: any): any;
    /**
     * Move the range to `anchorOffset`.
     *
     * @param {Number} anchorOffset
     * @return {Range}
     */
    moveAnchorOffsetTo(anchorOffset: any): any;
    /**
     * Move the range to `focusOffset`.
     *
     * @param {Number} focusOffset
     * @return {Range}
     */
    moveFocusOffsetTo(focusOffset: any): any;
    /**
     * Move the range to `anchorOffset` and `focusOffset`.
     *
     * @param {Number} anchorOffset
     * @param {Number} focusOffset (optional)
     * @return {Range}
     */
    moveOffsetsTo(anchorOffset: any, focusOffset?: any): any;
    /**
     * Move the focus point to the anchor point.
     *
     * @return {Range}
     */
    moveToAnchor(): any;
    /**
     * Move the anchor point to the focus point.
     *
     * @return {Range}
     */
    moveToFocus(): any;
    /**
     * Move the range's anchor point to the start of a `node`.
     *
     * @param {Node} node
     * @return {Range}
     */
    moveAnchorToStartOf(node: any): any;
    /**
     * Move the range's anchor point to the end of a `node`.
     *
     * @param {Node} node
     * @return {Range}
     */
    moveAnchorToEndOf(node: any): any;
    /**
     * Move the range's focus point to the start of a `node`.
     *
     * @param {Node} node
     * @return {Range}
     */
    moveFocusToStartOf(node: any): any;
    /**
     * Move the range's focus point to the end of a `node`.
     *
     * @param {Node} node
     * @return {Range}
     */
    moveFocusToEndOf(node: any): any;
    /**
     * Move to the entire range of `start` and `end` nodes.
     *
     * @param {Node} start
     * @param {Node} end (optional)
     * @return {Range}
     */
    moveToRangeOf(start: any, end?: any): any;
    /**
     * Normalize the range, relative to a `node`, ensuring that the anchor
     * and focus nodes of the range always refer to leaf text nodes.
     *
     * @param {Node} node
     * @return {Range}
     */
    normalize(node: any): any;
    /**
     * Return a JSON representation of the range.
     *
     * @return {Object}
     */
    toJSON(): {
      object: string;
      anchorKey: any;
      anchorOffset: any;
      focusKey: any;
      focusOffset: any;
      isBackward: any;
      isFocused: any;
      marks: any;
    };
    /**
     * Alias `toJS`.
     */
    toJS(): {
      object: string;
      anchorKey: any;
      anchorOffset: any;
      focusKey: any;
      focusOffset: any;
      isBackward: any;
      isFocused: any;
      marks: any;
    };
  }
  export default Range;
}

declare module "slate/models/schema" {
  const Schema_base: any;
  /**
   * Schema.
   *
   * @type {Schema}
   */
  class Schema extends Schema_base {
    /**
     * Create a new `Schema` with `attrs`.
     *
     * @param {Object|Schema} attrs
     * @return {Schema}
     */
    static create(attrs?: {}): any;
    /**
     * Create a `Schema` from a JSON `object`.
     *
     * @param {Object} object
     * @return {Schema}
     */
    static fromJSON(object: any): any;
    /**
     * Alias `fromJS`.
     */
    static fromJS: typeof Schema.fromJSON;
    /**
     * Check if `any` is a `Schema`.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isSchema(any: any): boolean;
    /**
     * Object.
     *
     * @return {String}
     */
    readonly object: string;
    readonly kind: string;
    /**
     * Get the rule for an `object`.
     *
     * @param {Mixed} object
     * @return {Object}
     */
    getRule(object: any): any;
    /**
     * Get a dictionary of the parent rule validations by child type.
     *
     * @return {Object|Null}
     */
    getParentRules(): {};
    /**
     * Fail validation by returning a normalizing change function.
     *
     * @param {String} violation
     * @param {Object} context
     * @return {Function}
     */
    fail(violation: any, context: any): (change: any) => void;
    /**
     * Normalize an invalid value with `violation` and `context`.
     *
     * @param {Change} change
     * @param {String} violation
     * @param {Mixed} context
     */
    normalize(change: any, violation: any, context: any): any;
    /**
     * Validate a `node` with the schema, returning a function that will fix the
     * invalid node, or void if the node is valid.
     *
     * @param {Node} node
     * @return {Function|Void}
     */
    validateNode(node: any): any;
    /**
     * Return a JSON representation of the schema.
     *
     * @return {Object}
     */
    toJSON(): {
      object: string;
      document: any;
      blocks: any;
      inlines: any;
    };
    /**
     * Alias `toJS`.
     */
    toJS(): {
      object: string;
      document: any;
      blocks: any;
      inlines: any;
    };
  }
  export default Schema;
}

declare module "slate/models/stack" {
  const Stack_base: any;
  /**
   * Stack.
   *
   * @type {Stack}
   */
  class Stack extends Stack_base {
    /**
     * Constructor.
     *
     * @param {Object} attrs
     */
    static create(attrs?: {}): any;
    /**
     * Check if `any` is a `Stack`.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isStack(any: any): boolean;
    /**
     * Object.
     *
     * @return {String}
     */
    readonly object: string;
    readonly kind: string;
    /**
     * Get all plugins with `property`.
     *
     * @param {String} property
     * @return {Array}
     */
    getPluginsWith(property: any): any;
    /**
     * Iterate the plugins with `property`, returning the first non-null value.
     *
     * @param {String} property
     * @param {Any} ...args
     */
    find(property: any, ...args: any[]): any;
    /**
     * Iterate the plugins with `property`, returning all the non-null values.
     *
     * @param {String} property
     * @param {Any} ...args
     * @return {Array}
     */
    map(property: any, ...args: any[]): any[];
    /**
     * Iterate the plugins with `property`, breaking on any a non-null values.
     *
     * @param {String} property
     * @param {Any} ...args
     */
    run(property: any, ...args: any[]): void;
    /**
     * Iterate the plugins with `property`, reducing to a set of React children.
     *
     * @param {String} property
     * @param {Object} props
     * @param {Any} ...args
     */
    render(property: any, props: any, ...args: any[]): any;
  }
  export default Stack;
}

declare module "slate/models/text" {
  const Text_base: any;
  /**
   * Text.
   *
   * @type {Text}
   */
  class Text extends Text_base {
    /**
     * Create a new `Text` with `attrs`.
     *
     * @param {Object|Array|List|String|Text} attrs
     * @return {Text}
     */
    static create(attrs?: string): any;
    /**
     * Create a list of `Texts` from `elements`.
     *
     * @param {Array<Text|Object>|List<Text|Object>} elements
     * @return {List<Text>}
     */
    static createList(elements?: any[]): any;
    /**
     * Create a `Text` from a JSON `object`.
     *
     * @param {Object|Text} object
     * @return {Text}
     */
    static fromJSON(object: any): any;
    /**
     * Alias `fromJS`.
     */
    static fromJS: typeof Text.fromJSON;
    /**
     * Check if `any` is a `Text`.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isText(any: any): boolean;
    /**
     * Check if `any` is a list of texts.
     *
     * @param {Any} any
     * @return {Boolean}
     */
    static isTextList(any: any): any;
    /**
     * Object.
     *
     * @return {String}
     */
    readonly object: string;
    readonly kind: string;
    /**
     * Is the node empty?
     *
     * @return {Boolean}
     */
    readonly isEmpty: boolean;
    /**
     * Get the concatenated text of the node.
     *
     * @return {String}
     */
    readonly text: any;
    /**
     * Add a `mark` at `index` and `length`.
     *
     * @param {Number} index
     * @param {Number} length
     * @param {Mark} mark
     * @return {Text}
     */
    addMark(index: any, length: any, mark: any): any;
    /**
     * Add a `set` of marks at `index` and `length`.
     *
     * @param {Number} index
     * @param {Number} length
     * @param {Set<Mark>} set
     * @return {Text}
     */
    addMarks(index: any, length: any, set: any): any;
    /**
     * Derive a set of decorated characters with `decorations`.
     *
     * @param {List<Decoration>} decorations
     * @return {List<Character>}
     */
    getDecoratedCharacters(decorations: any): any;
    /**
     * Get the decorations for the node from a `schema`.
     *
     * @param {Schema} schema
     * @return {Array}
     */
    getDecorations(schema: any): any;
    /**
     * Derive the leaves for a list of `characters`.
     *
     * @param {Array|Void} decorations (optional)
     * @return {List<Leaf>}
     */
    getLeaves(decorations?: any[]): any[];
    /**
     * Get all of the marks on the text.
     *
     * @return {OrderedSet<Mark>}
     */
    getMarks(): any;
    /**
     * Get all of the marks on the text as an array
     *
     * @return {Array}
     */
    getMarksAsArray(): any;
    /**
     * Get the marks on the text at `index`.
     *
     * @param {Number} index
     * @return {Set<Mark>}
     */
    getMarksAtIndex(index: any): any;
    /**
     * Get a node by `key`, to parallel other nodes.
     *
     * @param {String} key
     * @return {Node|Null}
     */
    getNode(key: any): this;
    /**
     * Check if the node has a node by `key`, to parallel other nodes.
     *
     * @param {String} key
     * @return {Boolean}
     */
    hasNode(key: any): boolean;
    /**
     * Insert `text` at `index`.
     *
     * @param {Numbder} index
     * @param {String} text
     * @param {String} marks (optional)
     * @return {Text}
     */
    insertText(index: any, text: any, marks: any): any;
    /**
     * Regenerate the node's key.
     *
     * @return {Text}
     */
    regenerateKey(): any;
    /**
     * Remove a `mark` at `index` and `length`.
     *
     * @param {Number} index
     * @param {Number} length
     * @param {Mark} mark
     * @return {Text}
     */
    removeMark(index: any, length: any, mark: any): any;
    /**
     * Remove text from the text node at `index` for `length`.
     *
     * @param {Number} index
     * @param {Number} length
     * @return {Text}
     */
    removeText(index: any, length: any): any;
    /**
     * Return a JSON representation of the text.
     *
     * @param {Object} options
     * @return {Object}
     */
    toJSON(options?: {}): {
      object: string;
      leaves: any;
    };
    /**
     * Alias `toJS`.
     */
    toJS(
      options: any
    ): {
      object: string;
      leaves: any;
    };
    /**
     * Update a `mark` at `index` and `length` with `properties`.
     *
     * @param {Number} index
     * @param {Number} length
     * @param {Mark} mark
     * @param {Object} properties
     * @return {Text}
     */
    updateMark(index: any, length: any, mark: any, properties: any): any;
    /**
     * Validate the text node against a `schema`.
     *
     * @param {Schema} schema
     * @return {Object|Void}
     */
    validate(schema: any): any;
    /**
     * Get the first invalid descendant
     * PREF: Do not cache this method; because it can cause cycle reference
     *
     * @param {Schema} schema
     * @returns {Text|Null}
     */
    getFirstInvalidDescendant(schema: any): this;
  }
  export default Text;
}

declare module "slate/models/value" {
  const Value_base: any;
  /**
   * Value.
   *
   * @type {Value}
   */
  class Value extends Value_base {
    /**
     * Create a new `Value` with `attrs`.
     *
     * @param {Object|Value} attrs
     * @param {Object} options
     * @return {Value}
     */
    static create(attrs?: {}, options?: {}): any;
    /**
     * Create a dictionary of settable value properties from `attrs`.
     *
     * @param {Object|Value} attrs
     * @return {Object}
     */
    static createProperties(attrs?: {}):
      | {}
      | {
          data: any;
          decorations: any;
          schema: any;
        };
    /**
     * Create a `Value` from a JSON `object`.
     *
     * @param {Object} object
     * @param {Object} options
     *   @property {Boolean} normalize
     *   @property {Array} plugins
     * @return {Value}
     */
    static fromJSON(object: any, options?: {}): any;
    /**
     * Alias `fromJS`.
     */
    static fromJS: typeof Value.fromJSON;
    /**
     * Check if a `value` is a `Value`.
     *
     * @param {Any} value
     * @return {Boolean}
     */
    static isValue(value: any): boolean;
    /**
     * Object.
     *
     * @return {String}
     */
    readonly object: string;
    readonly kind: string;
    /**
     * Are there undoable events?
     *
     * @return {Boolean}
     */
    readonly hasUndos: boolean;
    /**
     * Are there redoable events?
     *
     * @return {Boolean}
     */
    readonly hasRedos: boolean;
    /**
     * Is the current selection blurred?
     *
     * @return {Boolean}
     */
    readonly isBlurred: any;
    /**
     * Is the current selection focused?
     *
     * @return {Boolean}
     */
    readonly isFocused: any;
    /**
     * Is the current selection collapsed?
     *
     * @return {Boolean}
     */
    readonly isCollapsed: any;
    /**
     * Is the current selection expanded?
     *
     * @return {Boolean}
     */
    readonly isExpanded: any;
    /**
     * Is the current selection backward?
     *
     * @return {Boolean} isBackward
     */
    readonly isBackward: any;
    /**
     * Is the current selection forward?
     *
     * @return {Boolean}
     */
    readonly isForward: any;
    /**
     * Get the current start key.
     *
     * @return {String}
     */
    readonly startKey: any;
    /**
     * Get the current end key.
     *
     * @return {String}
     */
    readonly endKey: any;
    /**
     * Get the current start offset.
     *
     * @return {String}
     */
    readonly startOffset: any;
    /**
     * Get the current end offset.
     *
     * @return {String}
     */
    readonly endOffset: any;
    /**
     * Get the current anchor key.
     *
     * @return {String}
     */
    readonly anchorKey: any;
    /**
     * Get the current focus key.
     *
     * @return {String}
     */
    readonly focusKey: any;
    /**
     * Get the current anchor offset.
     *
     * @return {String}
     */
    readonly anchorOffset: any;
    /**
     * Get the current focus offset.
     *
     * @return {String}
     */
    readonly focusOffset: any;
    /**
     * Get the current start text node's closest block parent.
     *
     * @return {Block}
     */
    readonly startBlock: any;
    /**
     * Get the current end text node's closest block parent.
     *
     * @return {Block}
     */
    readonly endBlock: any;
    /**
     * Get the current anchor text node's closest block parent.
     *
     * @return {Block}
     */
    readonly anchorBlock: any;
    /**
     * Get the current focus text node's closest block parent.
     *
     * @return {Block}
     */
    readonly focusBlock: any;
    /**
     * Get the current start text node's closest inline parent.
     *
     * @return {Inline}
     */
    readonly startInline: any;
    /**
     * Get the current end text node's closest inline parent.
     *
     * @return {Inline}
     */
    readonly endInline: any;
    /**
     * Get the current anchor text node's closest inline parent.
     *
     * @return {Inline}
     */
    readonly anchorInline: any;
    /**
     * Get the current focus text node's closest inline parent.
     *
     * @return {Inline}
     */
    readonly focusInline: any;
    /**
     * Get the current start text node.
     *
     * @return {Text}
     */
    readonly startText: any;
    /**
     * Get the current end node.
     *
     * @return {Text}
     */
    readonly endText: any;
    /**
     * Get the current anchor node.
     *
     * @return {Text}
     */
    readonly anchorText: any;
    /**
     * Get the current focus node.
     *
     * @return {Text}
     */
    readonly focusText: any;
    /**
     * Get the next block node.
     *
     * @return {Block}
     */
    readonly nextBlock: any;
    /**
     * Get the previous block node.
     *
     * @return {Block}
     */
    readonly previousBlock: any;
    /**
     * Get the next inline node.
     *
     * @return {Inline}
     */
    readonly nextInline: any;
    /**
     * Get the previous inline node.
     *
     * @return {Inline}
     */
    readonly previousInline: any;
    /**
     * Get the next text node.
     *
     * @return {Text}
     */
    readonly nextText: any;
    /**
     * Get the previous text node.
     *
     * @return {Text}
     */
    readonly previousText: any;
    /**
     * Get the characters in the current selection.
     *
     * @return {List<Character>}
     */
    readonly characters: any;
    /**
     * Get the marks of the current selection.
     *
     * @return {Set<Mark>}
     */
    readonly marks: any;
    /**
     * Get the active marks of the current selection.
     *
     * @return {Set<Mark>}
     */
    readonly activeMarks: any;
    /**
     * Get the block nodes in the current selection.
     *
     * @return {List<Block>}
     */
    readonly blocks: any;
    /**
     * Get the fragment of the current selection.
     *
     * @return {Document}
     */
    readonly fragment: any;
    /**
     * Get the inline nodes in the current selection.
     *
     * @return {List<Inline>}
     */
    readonly inlines: any;
    /**
     * Get the text nodes in the current selection.
     *
     * @return {List<Text>}
     */
    readonly texts: any;
    /**
     * Check whether the selection is empty.
     *
     * @return {Boolean}
     */
    readonly isEmpty: any;
    /**
     * Check whether the selection is collapsed in a void node.
     *
     * @return {Boolean}
     */
    readonly isInVoid: any;
    /**
     * Create a new `Change` with the current value as a starting point.
     *
     * @param {Object} attrs
     * @return {Change}
     */
    change(attrs?: {}): any;
    /**
     * Return a JSON representation of the value.
     *
     * @param {Object} options
     * @return {Object}
     */
    toJSON(options?: {}): {
      object: string;
      document: any;
    };
    /**
     * Alias `toJS`.
     */
    toJS(
      options: any
    ): {
      object: string;
      document: any;
    };
  }
  export default Value;
}

declare module "slate/utils/generate-key" {
  /**
   * Generate a key.
   *
   * @return {String}
   */
  function generateKey(): any;
  /**
   * Set a different unique ID generating `function`.
   *
   * @param {Function} func
   */
  function setKeyGenerator(func: any): void;
  /**
   * Reset the key generating function to its initial state.
   */
  function resetKeyGenerator(): void;
  export default generateKey;
  export { setKeyGenerator, resetKeyGenerator };
}

declare module "slate/utils/memoize" {
  /**
   * Memoize all of the `properties` on a `object`.
   *
   * @param {Object} object
   * @param {Array} properties
   * @return {Record}
   */
  function memoize(object: any, properties: any, options?: {}): void;
  /**
   * In DEV mode, clears the previously memoized values, globally.
   *
   * @return {Void}
   */
  function resetMemoization(): void;
  /**
   * In DEV mode, enable or disable the use of memoize values, globally.
   *
   * @param {Boolean} enabled
   * @return {Void}
   */
  function useMemoization(enabled: any): void;
  export default memoize;
  export { resetMemoization, useMemoization };
}
